\section{Term Building}


\subsection{Task}

The intermediate language of Alba is strictly typed. All bound variables need
explicit types, calls of polymorphic functions need type arguments and
propositions need proofs.

The language for the user is much more liberal, otherwise it would be very
tedious to write programs in Alba.

The task of term building is to fill the gaps between the user language and
the intermediate language.





\begin{description}

\item[Binders]
  %
  The user can write in program text
  \begin{alba}
    \ x y := e

    all x y: p
  \end{alba}
  and the term builder has to generate $\lambda x^A y^B. e$ and $\Pi
  x^A y^B  . p$ i.e. it has to infer the argument types.


\item[Implicit Type Arguments]
  %
  Polymorphic functions and constructors need type arguments in the
  intermediate language. In order to construct an empty list the constructor
  $\text{nil}$ receives the object type as an argument. The user does not
  provide this information. Therefore the source code terms
  \begin{alba}
    1 ^ 2 ^ []           -- [] is nil and (^) is cons

    reverse ['a', 'b', ...]
  \end{alba}
  %
  have to be transformed to
  $$
  \begin{array}{l}
    \text{cons}\, \Natural\, 1 \,(\text{cons}\, \Natural\, 2\, (\text{nil}\,
    \Natural))

    \\

    \text{reverse}\, \text{Character} \, (\text{cons}\,\ldots)
  \end{array}
  $$



\item[Decreasing Fixpoint Argument]
  %
  Each fixpoint needs a decreasing argument for recursive calls. It is the
  task of the term builder to find one decreasing argument which is decreased
  in each recursive call or flag an error if it cannot find a decreasing
  argument.



\item[Ambiguity]
  %
  Global function (or constant) names are not unique in Alba. We can have
  different functions with the same name. Only the name together with the
  signature has to be unique.

  Whenever the builder encounters a name which does not uniquely specify a
  global function, it has to do the build with the different functions in
  parallel until a function is ruled out because of the typing rules.

\end{description}







\subsection{Implicit Arguments}


The type of a function must reduce to the form
$$
    \Pi x^A. B
$$

The argument $x$ is implicit if the following conditions are satisfied:

\begin{enumerate}

\item $A$ reduces to a kind.

\item $x$ occurs in $B$, but not in a function position.
\end{enumerate}

The first condition states that $x$ is either a type or a type constructor
variable. The second condition guarantees that it can be inferred from the rest
of the type.

\noindent Some examples of kinds:
\begin{alba}
    Any
    Int -> Any
    String -> Proposition
    Int -> String -> Proposition
\end{alba}


\noindent Example to explain implicit arguments.
\begin{alba}
class
    Specified (A: Any) (f: Predicate A): Any
:=
    (,) (x: A): f x -> Specified f

-- typing judgements
Specified: all (A: Any): Predicate A -> Any

(,): all (A: Any) (f: Predicate A) (x: A): f x -> Specified f
\end{alba}

For the function \code{Specified} the argument \code{A} is implicit since it
occurs in the type of the second argument. For the same reason the argument
\code{A} is implicit in the constructor \code{(,)}. But the argument \code{f} is
not implicit, because it occurs in the forth argument. It is implicit, because
it occurs in the result type.

E.g. \code{f} could be \code{isPrime}. The forth argument is a proof of
\code{isPrime x}. It proves (i.e. inhabits) some type equivalent to
\code{isPrime x}.  Therefore the predicate \code{isPrime} cannot be
reconstructed directly from a proof of \code{isPrime x} for some \code{x}.

\begin{quote}
    Potential problem: If a type constructor variable occurs as an argument to a
    function, the function might ignore the argument. Problem: Unification works
    on normal forms (at least on key normal forms) i.e. key redexes are reduced.
    The implicit argument might disappear during unification and therefore it
    cannot be assigned a value during unification.

    Possible solution: Disallow functions ignore type variable or type
    constructor variable arguments.

    \begin{alba}
        Eraser (A: Any): Any := Int

        poly (A: Any) (x: Eraser A): Int := x

        -- illegal call
        poly 1
    \end{alba}

    The implicit argument \code{A} cannot be inferred. The unification of
    \code{Int} with {Eraser A} a succeeds without assigning a type to the type
    variable \code{A}. This case can be avoided, if \code{Eraser} is illegal.

\end{quote}



\vskip 5mm
\subsection{Rules for Term Building}

The type reconstruction problem is undecidable. This is true already for system
F. Since system F is included in the type system of Alba, the type
reconstruction problem for Alba is undecidable as well.

Therefore we must require that some type annotations are present in order to
make the type reconstruction problem decidable. In the this section we describe
the rules which make the type reconstruction problem in Alba decidable.



\subsubsection{Type Variables must not be Ignored}

A type variable is a bound variable whose type is a kind or reduces to a kind.
We require that a type variable cannot be ignored. I.e. a type variable must
either appear in the subsequent part of the signature or in the body of a
function abstraction or function type.

This rule guarantees that implicit type variables are inferable from the rest of
the signature i.e. from a subsequent argument type or result type.


The following expressions are illegal
\begin{alba}
    -- Illegal expressions
    Erase (A: Any): Any :=
        Int

    \ (A: Any) := Int
\end{alba}




\subsubsection{Typed Function Abstractions and Implicit Arguments}

A function abstraction
\begin{alba}
    (\ x y ... := exp): E
\end{alba}
might have the required type \code{E}. The required type might come from an
explicit type annotation or because the function abstraction is used as an
argument of a function with a required argument type which is not a hole.

In that case \code{E} must have the form
\begin{alba}
    all (x: A) (y: B) ... : R
\end{alba}
The types \code{A, B, ...} are assigned as the types of the variables \code{x,
y, ...}.

It is not allowed that the function abstraction starts with implicit arguments
not included in the signature of \code{E}.

Furthermore, if the function abstraction has more formal arguments than the
expected type \code{E}, then the types of the exceeding formal arguments which
occur in a function position if \code{exp} have to be inferable from explicit
type annotations in the signature of the function abstraction.




\subsubsection{Untyped Variables in Function Positions}

If an untype bound variable occurs in a function position of an expression, then
the type of the bound variable must be inferable before the expression is built
i.e. the type of the bound variable must be inferable from the context of the
expression.

\paragraph{Redexes} Bound variables used in a function position in the function
part of a redex must have an explicit type annotation.

\begin{alba}
    -- Illegal
    (\ f g := a + f b * c - g d) arg1 arg2

    -- 'f' and 'g' must have type annotations!
\end{alba}


\paragraph{Top Level Recursive Functions} Since recursive functions are
fixpoints, they need a bound variable representing the recursive function which
occurs in a function position inside the function body. Therefore recursive
functions defined at the top level must have a type signature whose argument
types and whose result type must be inferable by looking at the signature only.

In order to have a uniform treatment of top level functions, we put this
requirement on all toplevel functions, regardless if recursive or not recursive.


\paragraph{Where Expressions} The type of a local definition must be usually
inferable by looking at the definition only.

I.e. the following form is illegal, if \code{f} is recursive.
\begin{alba}
    exp where
        f x y z := def
\end{alba}

There is one exception. The whole where expression has a required type and the
main expression is either \code{f} or \code{f v1 v2 ...} where \code{v1, v2,
...} are bound varibles of the surrounding function with an explicitely given
type. Reason: Having \code{f (v1: V1) (v2: V2) ... : R} the type of \code{f}
must be \code{all (v1: V1) (v2:V2) ... : R}. Side condition: The order of the
variables must respect dependencies.

Note that where expressions might be nested.
\begin{alba}
    exp where
        f x y z := fdef
        g x := gdef
\end{alba}
The analysis is outside in. The first definition to be analyzed is the
definition of \code{g}. If \code{g} is recursive i.e. if \code{g} occurs inside
\code{gdef} we need either a function annotiation for \code{g} or \code{g}
occurs in \code{exp} in the form of the above described exception.

Example of a legal where expression with a recursive local definition.
\begin{alba}
    induct
        (F: Natural -> Any)
        (start: F zero)
        (step: all i: F i -> F (add1 i))
        : all n: F n
    :=
        f where
            f n :=
                inspect n case
                    zero :=
                        start
                    add1 i :=
                        step i (f i)
\end{alba}
In that case \code{f} gets its type signature from the environment as \code{all
(n: Natural): F n}.

The following variant is legal as well.
\begin{alba}
    induct2
        (n: Natural)
        (F: Natural -> Any)
        (start: F zero)
        (step: all i: F i -> F (add1 i))
        : F n
    :=
        f n where
            f n :=
                inspect n case
                    zero :=
                        start
                    add1 i :=
                        step i (f i)
\end{alba}











\begin{enumerate}

\item A bound variable occurring in a function position must have an explicit
type annotation or its type must be inferrable from

    \begin{enumerate}

    \item the result type in case of a function abstraction (i.e. either the
    function abstraction has a type annotation or it is used as an argument and
    has therefore a required type)

    \item the type of the local definition in case of a where expression.
    \end{enumerate}

A bound variable occurring in a function position without explicit or inferred
type is reported as an error ({\em Cannot infer function type}).

\item A bound variable of a redex occurring in a function position must have an
explicit type annotation. Its type cannot be inferred neither from the required
result type nor from the argument types because of the possibility of implicit
arguments (for all formal arguments) and dependencies (for all formal arguments
starting from the second one).

\item At most one pending ambiguity is allowed. If there is already a pending
ambiguity, all upcoming ambiguities must be resolvable immediately. Otherwise an
error is issued. As soon as the pending ambiguity is resolved, new pending
ambiguities are allowed.

\end{enumerate}








\subsection{Constraint Typing}

At the start of term building we have a valid context $\Gamma$ and a syntactical
term $t_S$. The syntactical term does not have implicit arguments, the type
annotations are optional and the names can be ambiguous.

Furthermore we have a strip function which maps a language term into a
syntactical term. It strips off all implicit arguments and all type annotations
which are marked untyped (note: we record in the term the type annotations which
have not been present in the syntactic term) and maps all unambiguous names into
the corresponding ambiguous names (an unambiguous name might be a number and the
corresponding ambiguous name is a string).

A solution to the term building problem is a term $t$ and a type $T$ such that
$\Gamma \vdash t: T$ is valid and $\strip(t) = t_S$. The term building problem
might be unsolvable or it might have more than one solution. Clearly we want a
unique solution.

Multiple solutions can be introduced because of ambiguous types of literals and
names. If we restrict ourselves to minimal types $T$ and regard beta equivalent
types as the same type, the literals and the names are the only source of
ambiguity.


We introduce a constraint typing relation
$$
\ctype{\Gamma}{t:T}{M}{C}
$$
where $\Gamma$ is a valid context, $M \subseteq |\Gamma|$ is a set of
metavariables where each metavariable is either a type variable or a type
contructor variable, $C$ is a set of constraints of the form $A \eqmust B$ where
$A$ and $B$ are valid types in $\Gamma$.

A solution to $\ctype{\Gamma}{t:T}{M}{C}$ is a substitution $\sigma$ with
$|\sigma| \subseteq M$ such that $\Gamma \vdash \sigma t: \sigma T$ is a valid
typing judgement and for all $A\eqmust B$ in $C$ the terms $\sigma A$ and
$\sigma B$ are beta equivalent. I.e. $\sigma$ satisfies the constraints and
converts the constraint typing into a valid typing judgement.

Furthermore we want to maintain $\Gamma_0 = \Gamma - M$ i.e. the context
$\Gamma$ of the constraint typing relation is just an extension of the context
of the original problem by welltyped metavariables.

Since our metavariable are types or type constructors, their types are kinds (or
kind reducing). We use the typing rule
$$
\rulev
{\Gamma \vdash K: s}
{\Gamma, X^K \vdash X: K}
$$
to introduce them in a welltyped manner ($K$ is a kind i.e. either a sort or a
product $\Pi x^A. K$). We use the upper case letters $X$, $Y$, $Z$, $\ldots$ to
range over type (constructor) variables.


We want the constraint typing relation to be sound in the sense that every
solution $\sigma$ to the contraint problem
$\ctype{\Gamma}{t:T}{M}{C}$
generates a solution $\sigma t:
\sigma T$ of the original problem $(\Gamma_0,t_S)$ with $\strip(\sigma t) =
t_S$, if $|\sigma| = M$.

It is not meaningful to require completeness, i.e. to require each solution of
the original problem can be generated from a solution of the constraint problem.
This is not meaningful, because the type inference problem is not decidable for
the calculus. Remember that even for system $F$ the type inference problem is
not decidable.

The only meaningful outputs of a term building algorithm can be
\begin{itemize}

\item There is a unique solution

\item There is more than one solution

\item There is no solution

\item Some type annotations or implicit arguments cannot be inferred.

\end{itemize}

The last point indicates a semidecision. The algorithm fails. But it tells the
user that there might be a solution if more type annotations where present.


















\subsection{Hindley-Milner Explosion}

\begin{alba}
    f0 (\ x := x) where
        f0 x := f1 (f1 x)
        f1 x := f2 (f2 x)
        ...
        f4 x := f5 (f5 x)
        f5 x := (x,x)

    f4 x := f5 (f5 x)   ~>  ((x,x),(x,x))

    f3 x := f4 (f4 x)   ~>  ((((x,x),(x,x)),((x,x),(x,x))),(((x,x),(x,x)),((x,x),(x,x))))

    -- f4 x contains 4 x               4
    -- f3 x contains 4^2 x            16
    -- f2 x contains 4^3 x            64
    -- f1 x contains 4^4 x           256
    -- f0 x contains 4^5 x          1024
\end{alba}


At a small scale
\begin{alba}
    f0 "Hello" where
        f0 x := f1 (f1 x)
        f1 x := (x,x)

    -- with type annotations
    f0 "Hello": ((String,String),(String,String))
    where
        f0 (A: Any) (x: A): ((A,A),(A,A)) :=
            f1 (f1 x)
        f1 (A: Any) (x: A): (A,A) :=
            (x,x)


    (,): all (A B: Any): A -> B -> (A,B)
\end{alba}
All functions must be polymorphic, otherwise the expression would not be typable.

Type inference of \code{f1} needs the introduction of a metavariable
\code{A:Any} for the type of the variable \code{x}. At the end of the analysis
of \code{f1} the metavariable remains open. Hindley-Milner requires to
universally quantify the type variable.

\begin{alba}
    -- textual substitution
    f0 "Hello" where
        f0 y := f1 (f1 y)
        f1 x := (x,x)

    (\ y := f1 (f1 y)) "Hello"

    (\ y := (\ x := (x,x)) ((\ x := (x,x)) y)) "Hello"
\end{alba}











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip 5mm
\subsection{Redexes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Redexes are challenging in term building. Some examples of redexes.

\begin{alba}
    (\ x := e) a

    1 + f 10 where
        f x := 2 * x

    (\ f := 1 + f 10) (\ x := 2 * x)

    (\ TC := TC (TC Int)) List
\end{alba}
%





\subsubsection{Untyped Multiargument Redexes}

\begin{alba}
    (\ x := e) a

    (\ x y := e) a b
\end{alba}

In \code{(\textbackslash x := e) a} we could build \code{a} first getting a type
\code{A} for the term, and then analyse \code{\textbackslash (x:A) := e}.

This does not work for \code{(\textbackslash\ x y := e) a b} for the second
argument. The type of \code{y} might depend on \code{x}. Example
\begin{alba}
    predecessor (n: Natural): isSuccessor n -> Natural

    (\ n p := predecessor n p) 1 trueValid
\end{alba}
The only valid type of \code{p} is \code{isSuccessor n}. However the type of
\code{trueValid} is \code{true} which is equivalent to \code{isSuccessor 1}, but
not to \code{isSuccessor n} for arbitrary \code{n}.

Therefore: In a multiargument redex we can use the type of the first argument as
the type of the first formal argument. But we cannot use the type of the second
argument as the type of the second formal argument.


\vskip 5mm
\subsubsection{Implicit Arguments}

\begin{alba}
    (\ x := e) a
\end{alba}

Theoretically the argument \code{x} could be implicit (either a type or a type
constructor variable). Example

\begin{alba}
    (\ A := ((\ e := [e]): A -> List A) ) 1
\end{alba}
%
This example is contrived. Why should be write a generic function abstraction
and then specialize it immediately? However the term is syntactically correct
and typeable. The following term is equivalent.

\begin{alba}
    (\ (A: Any) (e: A) := [e]) 1
\end{alba}

If we want to type silly but legal redexes correctly, it might not be a good
idea to analyze the argument first and then use the argument type as a type for
the first formal argument. We should analyze the function abstraction first and
then the argument with a required type.

However the strategy to analyze the function abstraction first does not work
well in the following case
%
\begin{alba}
    (\ f := 1 + f 10) (\ x := 2 * x)
\end{alba}
%
In that case \code{(+)} might be ambiguous for ints, floats, naturals etc. and
the number literals are ambiguous as well. Analyzing the function abstraction
with the general typing \code{f: all (x:A): F x} where \code{A} and \code{F}
are metavariables, causes a combinatorial explosion for all valid combinations
for both metavariables.

Here it would be better analyze the argument first with some ambiguity, but no
explosion. And then analyze the function abstraction which remains only linear
ambiguous.

The second example is suceptible to combinatorial explosion, because the formal
argument \code{f} is used in a function position which requires at least two
metavariables to get the most general type.







\vskip 5mm
\subsubsection{Generic Combinators}



\begin{alba}
    pair A B x y C (f: A -> B -> C): C :=
        f x y

    pair 1 2: all C: (Num1 -> Num2 -> C) -> C
\end{alba}

There might already start a combinatorial explosion, because a numeric literal
is ambiguous. It can be a \code{Natural}, \code{Float}, \code{Int},
\code{Int64} ...




\vskip 5mm
\subsubsection{Restriction: All Functions Typed}

Possible Restriction: All bound variables which are used in a function position
of an expression must have a type prior to analyzing the expression. The type
can be either

\begin{itemize}
\item explicitly provided by a type annotation

\item implicitly provided by a required type of a function abstraction.
\end{itemize}

Example

\begin{alba}
    (\ (f: Int -> Int) := 1 + f 10) (\ x := 2 * x)
\end{alba}

This annotation forces all numbers to be of type \code{Int}.

This requirement might be a good trade off between easy code writing and code
analysis. The combinatorial explosion can be very problematic. Consider the
following case.

\begin{alba}
    (\ f := 1 + f 1 2 3 4 5) (\ x1 x2 x3 x4 x5 := x1 + x2 + x3 + x4 + x5)
\end{alba}

Having 3 number types (at least we have \code{Natural, Int, Float}) results in
$3^5 = 243$ variants for the function type which are in the second step reduced
to $3$ variants, because $(+)$ requires that both arguments and the result have
the same type. A simple type annotation on the bound variable \code{f} would
have reduced the number of variants to $1$ on all subexpressions.







\vskip 5mm
\subsubsection{Ambiguity}

We have two sources of ambiguity in the language

\begin{itemize}

\item Number literals: The number literal \code{1} can have one of the types
\code{Int, Natural, Float, Integer, Byte, ...}

\item Global functions: The same name can be used as the name for different
global functions as long as the signatures of the functions are different.

\end{itemize}

We want to resolve ambiguities as early as possible and we certainly don't want
any combinatorial explosion due to ambiguities.

\begin{alba}
    (1: Int) + 2 + 3 + 4 + 5

    1 + 2 + 3 + 4 + 5: Float
\end{alba}

The second expression can be analyzed more efficiently than the first, all
ambiguities are resolve immediately.

The first expression has $n$ variants until the first operand is found, which
selects the correct variant.

Both variants are legal, because no combinatorial explosion is possible.

The expressions

\begin{alba}
    1 = 2: Proposition

    1 = 2: Decision (1 = 2)
\end{alba}

are inherently ambiguous. The ambiguity is unresolved because the propositional
equality \code{(=)} just requires that both arguments are of the same type, but
the type can be arbitrary. And since that type of the arguments to be compared
is not in the result type of the comparison, the expression cannot be
disambiguated by a type annotation on the result type.

Each number type has a decision procedure to decide equality. Each decision
procedure connects the argument type with the result type. Therefore the correct
decision procedure for the equality test can be selected by knowing the result
type of the decision procedure.


To disambiguate we need some type annotations.

\begin{alba}
    (1: Int) = 2: Proposition

    1 = 2: Decision ((1: Natural) = 2)

    (1: Float) = 2: Decision (1 = 2)
\end{alba}


In order to reduce the linear ambiguities further we could introduce an abstract
datatype \code{Number} which has addition, multiplication, order relation and
decision functions for equality and order.


Ambiguous global names must have different type signatures. I.e. either one or
more of the argument types and or the result type are different.

If only some argument types are different, the ambiguity cannot be resolved by
the required result type. This is can be a problem for relations. E.g. all
numeric types have an order relation

\begin{alba}
    (<=): Int -> Int -> Proposition             -- Endorelation Int

    (<=): Natural -> Natural -> Proposition     -- Endorelation Natural

    (<=): Float -> Float -> Proposition         -- Endorelation Float
\end{alba}

Therefore expressions like \code{1 <= 2} are inherently ambiguous and need a
type annotation to make them legal. Expressions like \code{a <= b} are
unambiguous only if at least one of the arguments has a unique type (this should
be the normal case).

Furthermore we have deciders for the order relation

\begin{alba}
    (<=): all (x y: Int): Decision (x <= y)

    (<=): all (x y: Natural): Decision (x <= y)

    (<=): all (x y: Float): Decision (x <= y)
\end{alba}

An expression like \code{Decision (a <= b)} is unambiguous only if at least one
of its arguments has a unique type.

A non polymorphic function always requires a unique type for each of its
arguments. Therefore ambiguous expressions cannot enter as arguments to a
monomorphic function.

Ambiguous expressions might enter as arguments to polymorphic functions (e.g.
propositional equality, see above). More than one type parameter is possible.
Therefore more than one ambiguous argument can enter a polymorphic function.

This might lead to some combinatorial explosion. The resulting ambiguity can
only be resolve by another argument or the result type. If neither another
argument nor the required result type resolve the ambiguity, then an error has
to be flagged, because the ambiguity in that case unresolvable.

QUESTION: Is there any possibility to avoid the combinatorial explosion in case
of multiply polymorphic functions? Is such a case realistic.

The pair \code{(1,2)} is ambiguous, if there is no required result type (or the
result type is polymorphic).

An ambiguous name or literal can be entered only if the ambiguity cannot be
resolved immediately. We call such an ambiguity a pending ambiguity. This can
happen, if the name or literal is used as a polymorphic argument of a
polymorphic function.

Under what conditions can pending ambiguities appear?
\begin{itemize}

\item Name or literal used as a polymorphic argument of a polymorphic function.

\item Name or literal used in a function position where there is no required
result type or the function type does not yet allow to unify the result type
with the expected result type because the result type depends on actual
arguments.

\end{itemize}





\vskip 5mm
\subsubsection{Where Expressions}

Example:

\begin{alba}
    1 + f 10 20 where
        f x y := x * y
\end{alba}

Where expressions are local definitions or local abbreviations. The main
expression contains a variable and the variable is defined within a following
where block. The main expression can contain more than one variable and each
variable is defined within the where block.

It is important, whether the variable is used in the main expression in a
function position or only in argument positions. If the variable is used in a
function position, it is better to analyze the definition first and then the
main expression. If the variable is used only in argument positions, it might be
better to analyze the main expression first to get a required type for the
variable and then analyze the defining expression.

The analysis can be done with a hole for the variable type. An analysis of the
main expression where the variable is used only in argument positions might fill
the type hole. An analysis of the definition term might do the same. As opposed
to a function abstraction or a function type, we don't use the variable to
abstract over it.

Some more examples:
\begin{alba}
    reverse A (list: List A): List A :=
        f [] list where
            f accu list :=
                inspect list case
                    [] :=
                        accu
                    head +: tail :=
                        f (head +: accu) tail

\end{alba}
In that case the result type and the type of the second argument of \code{f} are
given by looking only at the signature of \code{reverse} and the actual
arguments of the function call \code{f [] list}. Note that \code{[]} can be
polymorphic. I.e. its type is either \code{all B: List B} or \code{List B} for
some specific \code{B}. Therefore by looking at the main expression we can infer
two possible types for \code{f}
\begin{alba}
    f: (all B: List B) -> List A -> List A
    f: List B -> List A -> List A
\end{alba}

The local definition has \code{f} in a function position in its definition
block. Without other information we could just use a generic telescope as a type
of \code{f}
\begin{alba}
    f: (x: B) (y: C x): R x y
    -- where
    B: Any
    C: A -> Any
    R: all (x: A): C x -> Any
\end{alba}
Further analysis generate the unification constraints:
\begin{alba}
    C accu = List D            -- because of the pattern match
    R accu list = B
    B = D
    C accu = List D

\end{alba}










\vskip 5mm
\subsection{Pattern Match}

$$
    \case (\fbold, \lambda \ybold^{\Abold} x^T . R)
$$


\begin{alba}
    -- without inspect
    case
        c z0 z1 ... := ce       -- one clause for each constructor
        ...

    -- with inspect
    inspect
        ia0; ia1; ...; e    -- ia0,... index arguments
                            -- e: expression to be inspected
    case
        c z0 z1 ... := ce       -- one clause for each constructor
        ...
\end{alba}

The type of a case expression is a function type with $n + 1$ argument types
where $n$ is the number of indices of the indutive type.

If we have an expected type for a case expression it must have the form
\begin{alba}
    all (y: A) (x: T): R
\end{alba}

\code{R} can still be a function type. We have to find out the inductive type
and the index types to split up the type correctly. The type alone does not
uniquely identify the inductive type in which is pattern matched. Examples:

\begin{alba}
    all (n m: Natural): n + m = m + n

    all (n m: Natural): n <= m => n <= successor m
\end{alba}

The first proposition is proved by a pattern match on \code{n} and the second
one is proved by a pattern match on \code{n <= m} with the indices \code{n} and
\code{m}.

Therefore we have to look at the constructors as well to identify the inductive
type.

Each match clause has the form \code{c z0 z1 ...} where \code{c} is the name of
a constructor (can be an infix operator as well) and \code{z0, z1, ...} are
names of formal arguments.

If there is an inspect clause, we have a clear indication on the indices and the
object of the inductive type. The analysis of the indices gives the index types
and the analysis of the inspected expression gives the inductive type. If there
is an expected type, we are able to reconstruct the type of the case expression.

However there might be difficulties in reconstructing the elimination function.
The expected result type is
\begin{alba}
    R[ya0:=ia0, y1:=ia1, ..., x:=e]
\end{alba}








\subsection{Contexts with Holes}

During term building we have to be able to introduce placeholders or holes for
terms or types which are not yet known. We introduce the holes in a form which
maintains the context welltyped. In the course of the term building we fill the
holes by maintaining the wellformedness of the context.

It is important that every context with holes is well formed. In the following
we show, how to introduce variables representing holes into a context and
maintain the wellformedness condition.

Let $u$, $v$, $w$ be variables representing predicative sorts (i.e. they stand
for $\Any_i$ for an arbitrary $i$). $u'$ represents $\Any_{i+1}$, when $u$
represents $\Any_i$.


\subsubsection{Introduce type variables}

If $\Gamma$ is a wellformed context, then $\Gamma, A^u$ is valid as well. This
fact can be proved by looking at a specialized version of the variable
introduction rule
%
$$
\ruleh
{\Gamma \vdash u: u'}
{\Gamma, A^u \vdash A: u}
$$
%
Having a valid context $\Gamma,A^u$ we can introduce variables of type $A$ i.e.
form $\Gamma, A^u, x^A$ with the two holes $A$ and $x$.

Note that we can fill the holes with $x := \Any_0$ and $A := \Any_1$ by
generating the constraint $\Any_1 < u$.

If we analyze an expression $e$ of unkown type in a context $\Gamma$, we can
introduce a variable $E$ representing the unknown type and a variable $e$
representing the expression and start with the context
%
$$
\Gamma, E^u, e^E
$$




\subsubsection{Introduce type constructor variables}

From the product rule and the subtype rule we can derive the validity of
%
$$
\rulev
{
    \Gamma \vdash A: u
    \\
    \Gamma, x^A \vdash B: v
}
{
    \Gamma \vdash \Pi x^A. B : \max(u, v)
}
$$
%
We can specialize this rule to
%
$$
\rulev
{
    \Gamma \vdash A: u
    \\
    \Gamma, x^A \vdash v: v'
}
{
    \Gamma \vdash A \to v : \max(u,v')
}
$$
and by using the variable introduction rule we generate the valid context
%
$$
\Gamma, F^{A \to v}
$$
i.e. introduce a hole $F$ representing a type constructor. In this context the
following typing derivation is valid
%
$$
\rulev
{
    \Gamma, F^{A \to v} \vdash A : u
    \\
    \Gamma, F^{A \to v}, x^A \vdash x: A
    \\
    \Gamma, F^{A \to v}, x^A \vdash F x: v[x := x]
}
{
    \Gamma, F^{A \to v} \vdash \Pi x^A. F x: \max(u, v)
}
$$
%
Based on this validity we can introduce a variable $f$ having as its type the
product
$$
\Gamma, F^{A \to v}, f^{\Pi x^A. F x}
$$
%
With all these derivations it can be seen, that the function application
$$
\Gamma, A^u, a^A, F^{A \to v}, f^{\Pi x^A. F x} \vdash f a: F a
$$
%
based on pure holes is valid.




\subsubsection{Introduce higher type constructor variables}

In the previous section we derived the introduction of a type constructor with
one variable and a corresponding function variable.
$$
\rulev
{
    \Gamma \vdash A: u
    \\
    \Gamma \vdash a: A

}
{
    \Gamma, F^{A\to v} \vdash \Pi x^A. F x: \max(u,v)
    \\
    \Gamma, F^{A\to v}, f^{\Pi x^A. F x} \vdash f a: F a
}
$$

We can go one step further and iterate the rule
$$
\rulev
{
    \Gamma \vdash A_i: u_i
    \\
    \Gamma, x_i^{A_i} \vdash B: v
}
{
    \Gamma \vdash \Pi x_i^{A_i}. B : \max(u_i, v)
}
$$
%
and generate
%
$$
\rulev
{
    \Gamma \vdash A: u_A
    \\
    \Gamma \vdash B: u_B
    \\
    \ldots
    \\
    \Gamma \vdash Y: u_Y
    \\
    \Gamma \vdash Z: u_Z
}
{
    \Gamma \vdash Z \to v : \max(u_Z, v')
    \\
    \Gamma \vdash Y \to Z \to v: \max(u_Y, u_Z, v')
    \\
    \ldots
    \\
    \Gamma
    \vdash
    A \to B \to \ldots \to Z \to v:
    \max(u_A, u_B, \ldots, u_Z, v')
}
$$

Since $A \to B \to \ldots v$ is a type (i.e. its type is a sort), we can
introduce a variable into the context which has this type. Having this we can
form a product type, a placeholder for function and apply that function to many
arguments.
%
$$
\rulev
{
    \Gamma \vdash A: u_A
    \\ \ldots \\
    \Gamma \vdash A \to B \to \ldots v : \max(u_A, u_B, \ldots, v')
}
{
    \Gamma, a^A, b^B, \ldots, F^{A\to \ldots \to v}
    \vdash
    \Pi x^A y^B \ldots. F x y \ldots: \max(u_A, u_B, \ldots, v)

    \\
    \Gamma, a^A, b^B, \ldots, F^{A\to \ldots \to v}, f^{\Pi x^A \ldots F x \ldots}
    \vdash
    f a b \ldots : F a b \ldots
}
$$




\subsection{The Most General Telescope}


In a product $\Pi \xbold^\Abold. R$ the types $A_i$ can depend on $x_0, \ldots,
x_{i-1}$.

$$
\rulev
{
    \Gamma \vdash A: u_A
    \\
    \Gamma \vdash B: A \to u_B
    \\
    \Gamma \vdash C: \Pi x^A. B x \to u_C
    \\
    \ldots
    \\
    \Gamma \vdash F: \Pi x^A y^{B x} z^{C x y} \ldots v
}
{
    \Gamma
    \vdash
    \Pi x^A y^{B x} z^{C x y} \ldots . F x y z \ldots
    :
    \max(u_A, u_B, \ldots, v)
}
$$








\subsection{Unification}

During term building we first introduce holes into the context and then we try
to fill these holes by some candidate terms. Let's assume we have a hole $x^R$
where $R$ is the required type of the hole $x$. Then we construct a term $e$
with actual type $A$. We can fill the hole $x$ with $e$ only if $R$ is a
supertype of $A$ i.e. if $A \le R$ is valid. Since we do not yet know the
validity, we can only state the requirement $A \lemust R$ which reads \emph{The
holes in $A$ and $R$ must be filled such that the substituted $A$ is a subtype
of the substituted $R$}.



\begin{definition} A \emph{Unification Problem} consists of a context $\Gamma$
with holes, a substitution $\sigma$ of some of the holes and a set of
unification requirements. A unification requirement has the form $(\Psi, A
\lemust B)$ or $(\Psi, A \eqmust B)$ where $\Gamma,\Psi \vdash A: T_A$ and
$\Gamma,\Psi \vdash B: T_B$ are valid typing judgements for some $T_A$ and
$T_B$. In other words $\Gamma,\Psi$ is a wellformed context and $A$ and $B$ are
valid terms in this context.

Furthermore we require that all variables which have already substitutions, do
not occur anymore in the unification problem. I.e. as soon as we encounter a
valid substitution $x:=e$ we replace all occurrences of the hole $x$ in the
unification problem with the term $e$ (Substitute $e$ for $x$).

A solution to a unification problem is a substitution of some holes such that
all unification requirements are satisfied.
\end{definition}


Since we have only valid contexts and terms in a unification problem, we can
assume that all terms are in normal form. I.e. all terms in a unification
problem are generated by the grammar
$$
\begin{array}{lllll}
    t &::=&  s & \text{sort}
    \\
    &\mid&  u & \text{universe variable}
    \\
    &\mid& x a_0 a_1 \ldots & \text{variable application}
    \\
    &\mid& \Pi x^A. B       & \text{product}
    \\
    &\mid& \lambda x^A. e   & \text{abstraction}
\end{array}
$$


In a unification problem we encounter only the following type of holes.
\begin{itemize}

\item Implicit arguments: The type of these holes are always kinds, i.e. the
implicit arguments stand either for types or type constructors. The types of
these holes do not contain any universe variables.

\item Unknown types of expressions (or bound variables) and the corresponding
types of these types. The types of these holes usually contain universe
variables.

\end{itemize}


Cases to consider
\begin{description}
\item[sort-sort]
Sorts can only be unified if they figure in the required relation.
$$
\rulev {
    E + \Psi \vdash s_1 \relmust{r} s_2, \quad \sigma
    \\
    \Psi \vdash s_1 \mathrel{r} s_2
}
{
    E, \quad \sigma
}
$$

\item[universe-universe] Universe constraints like $u_1 \relmust{r} u_2$ can be
added to the unification problem only if no circularity is possible within the
constraints. If circularity appears, then the problem is unsolvable.


\item[same variable]
$$
\rulev
{
    E + \Psi \vdash x \abold \relmust{r} y \bbold, \quad \sigma
    \\
    x = y
    \\
    |\abold| = |\bbold|
}
{
    E + \Psi \vdash a_0 \eqmust b_0 + \Psi \vdash a_1 \eqmust b_1 + \ldots,
    \quad \sigma
}
$$






\item[rigid-flex]

$$
\rulev
{
    E + \Psi \vdash t \relmust{r} F x y \ldots, \quad \sigma
    \\
    \text{$F$ is a metavariable}
    \\
    \Gamma \vdash F: \Pi x^A y^{Bx} \ldots. R
    \\
    \{x, y \ldots\} \subseteq |\Psi|
    \\
    \text{FV}(t) \cap |\Psi| \subseteq \{x,y,\ldots\}
    \\
    \Psi \vdash \text{type}\, t \le \text{type}(F x y \ldots)
}
{
    E[F := \lambda x^A y^{Bx}\ldots . t],
    \quad
    \sigma + (F := \lambda x^A y^{Bx}\ldots . t)
}
$$
%
Note that the substitution $F := \lambda x^A y^{Bx}\ldots . t$ unifies the two
expressions $t$ and $F x y \ldots$ in the sense that they become beta equivalent
after the substitution. We can see this by
$$
\begin{array}{lll}
    F x y \ldots &=& (\lambda x^A y^{Bx}\ldots . t) x y \ldots
    \\
    &\reduce& t
\end{array}
$$


\item[flex-rigid]

A unification obligation of the form $\Psi \vdash F x y \ldots \relmust{r}
t$ is just a mirror image of the previous case, if the conditions are satisfied.



\item[flex-flex]

$$
\rulev
{
    E + \Psi \vdash F x y \ldots \relmust{r} G x y \ldots,
    \quad \sigma
    \\
    \text{$F$ and $G$ are metavariables}
    \\
    \{x, y \ldots\} \subseteq |\Psi|
    \\
    \text{type}(F x y \ldots) \le \text{type}(G x y \ldots)
}
{
    E[G := F], \quad \sigma + (G := F)
}
$$





\item[product-product]

For products we have two rules. The first rule applies if the argument types are
not yet unified.
$$
\rulev
{
    E + \Psi \vdash \Pi x^A.B \relmust{r} \Pi x^C. D, \quad \sigma
    \\
    \lnot \Psi \vdash A \mathrel{r} C
}
{
    E
    + \Psi \vdash A \eqmust{r} C
    + \Psi \vdash \Pi x^A.B \relmust{r} \Pi x^C. D,
    \quad \sigma
}
$$
%
The second rule applies, when the argument types have been unified.
$$
\rulev
{
    E + \Psi \vdash \Pi x^A.B \relmust{r} \Pi x^C. D, \quad \sigma
    \\
    \Psi \vdash A \mathrel{r} C
}
{
    E
    + \Psi,x^A \vdash B \relmust{r} D
    ,\quad \sigma
}
$$


\end{description}



\subsection{Examples}


\subsubsection {Function Application}

We analyze the source code expression
\begin{alba}
    1 |> identical

    -- where
    (|>): all (C: Any) (G: C -> Any) (x: C) (g: all x: G x) : G x
    1: int
    identical: all (D: Any) (x: D): x = x
\end{alba}
%
The expression \code{1 |> identical} is an application with two arguments,
therefore we need the context
$$
    [
        A^{u_A}, a^A,
        B^{A\to u_B}, b^{Bx},
        F^{\Pi x^A. B x \to u_F}, f^{\Pi x^A y^{Bx}. F x y}
    ]
$$
%
where the hole $a$ and $b$ represent the two arguments and the hole $f$
represents the function.


\begin{enumerate}

\item Analyze the function term $(\triangleright): \Pi C^\Any G^{C\to\Any} x^C
g^{\Pi x^C.Gx}. Gx$:

    \begin{enumerate} \item Add the holes $C^\Any$ and $G^{C\to\Any}$ as
    implicit arguments to the context.

    \item Unify $\Pi x^C g^{\Pi x^C.Gx}. Gx \lemust \Pi x^A y^{Bx}. F x y $.

    Creating the unification problem
    $$
    \begin{array}{l}
        ([], C \eqmust A)
        \\
        ([x^C], \Pi x^C . G x \eqmust B x)
        \\
        ([x^C, y^{\Pi x^C.G x}], G x \lemust F x y)
    \end{array}
    $$
    %
    with the solution
    %
    $$
    \begin{array}{l}
        \Any \le u_A
        \\
        \Any \le u_B
        \\
        \Any \le u_F
        \\
        A := C
        \\
        B := \lambda x^C . \Pi x^C. G x
        \\
        F := \lambda x^C y^{\Pi x^C.Gx} . G x
    \end{array}
    $$

    Note that $ C := A$ cannot be part of the solution because the constraint
    $u_A \lemust \Any$ is not satisfiable. No universe variable can be bounded
    by a fixed predicative universe. Universe variables must be free floating.

    \end{enumerate}

\item Analyze $1: I$ as the first argument $a$ where we use $I$ as an
abbreviation for \code{Int}.

We have to unify $ I \lemust C$ which is satisfied by $C := I$.


\item Analyze $i: \Pi D^\Any z^D. z = z$ as the second argument $b$ where we use
$i$ as an abbreviation for \code{identical}.

    \begin{enumerate}
    \item Add the hole $D^\Any$ as implicit argument to the context.

    \item Unify $\Pi z^D. z = z \lemust \Pi x^I. G x$

    Creating the unification problem
    $$
    \begin{array}{l}
        D \eqmust I
        \\
        x = x \lemust G x
    \end{array}
    $$
    %
    with the solution
    %
    $$
    \begin{array}{l}
        \Prop \le \Any
        \\
        D := I
        \\
        G := \lambda x^I. x = x
    \end{array}
    $$

    \end{enumerate}
\end{enumerate}


\subsubsection{Product}

We analyze the source code expression
\begin{alba}
    all C: C -> C

    -- which is equivalent to
    all (x: _) (y: x): x
\end{alba}

A product with two arguments has the most general form.
%
\begin{alba}
    all (x: A) (y: B): R
\end{alba}
%
and we need the following context
$$
\Gamma, A^{u_A}, x^A, B^{u_B}, y^B, R^{u_R}
$$
%
with the metavariables $A$, $B$ and $R$ representing types (or sorts).



\begin{enumerate}

\item First argument \code{(x: \_)}: There is nothing to do, because we have no
explicit type for $x$.

\item Second argument \code{(y: x)}:

We want to try the substitution $B := x$. Before we have to solve the constraint
$[x^A] \vdash A \lemust u_B$ which generates the constraint $u_A \lemust u_B'$.
Since the latter constraint does not create any universe inconsistency, we can
do the substitution.

\item Result type \code{x}:

We want to try the substitution $R := x$. This generates the constraint
$[x^A, y^x] \vdash A \lemust u_R$
which in turn generates the constraint
$u_A \lemust u_R'$.
%
Again, no circularity has been introduced, therefore the substitution is valid.

\end{enumerate}

The unification created the substitution $[B := x, R := x]$ and the constraints
$[u_A \lemust u_B', u_A \lemust u_R']$. However we have no substitution for the
metavariable $A$.

But since we have used $x$ as a substitution for types, we know, that $x$ must
be a type. This implies that its type i.e. $A$ must be some sort $s$ which has
to satisfy the constraints $[s \lemust u_B, s \lemust u_R]$. Therefore the most
general replacement for $A$ is described by $A := \Any$. The substitution $A :=
\Prop$ would be possible as well, but it is not the most general one.


The substitutions $[B := x; R := x]$ are possible only if $x$ is a type which
implies that $A$ must be a sort. Since $A$ is in a position, where an explicit
type (i.e. a user given type) is possible, the metavariable $A$ can only
represent $\Any$ or $\Prop$. Other sorts cannot be entered by the user. I.e.
whenever we get a unification obligation $A \relmust{r} u$ when $u$ is a
universe variable, we know that the metavariable $A$ must represent one of the
sorts $\Any$ and $\Prop$. In case that the relation is equality (which is
normally not the case), the only possibility is $\Any$.





\subsection{Undecidability}

If a source code expression is type annotated and all bound variables have
explicit types, then all implicit arguments can be inferred. However there might
remain ambiguities. Example:
%
\begin{alba}
   2 = 3  => 3 = 4: Proposition
\end{alba}
%
This expression is type annotated and there are no untyped bound variables.
However the expression is ambiguous.
%
\begin{alba}
   (2: Int)   = (3: Int)    =>  (3: Float) = (4: Float) : Proposition
   (2: Float) = (3: Float)  =>  (3: Float) = (4: Float) : Proposition
   ...
\end{alba}
%
Reason: The equality operator \emph{looses} information, because it has the
type
%
\begin{alba}
    (=): all (A: Any): A -> A -> Proposition
\end{alba}
%
It only requires that the two explicit operands have the same type. But the type
is not propagated into the result type.








\subsection {Source Code Expressions}

\begin{enumerate}

\item Terminals

    \begin{enumerate}
    \item \code{Proposition}
    \item \code{Any}
    \item Literals: String, Character, Number
    \item Identifier (or operator)
    \end{enumerate}

\item Expression with Type Annotation \code{exp : T}

\item Function Application \code{f a b c ...}

\item Function Abstraction
\begin{alba}
    \ (x:A) (y:B) ... : RT := exp
\end{alba}

\item Function Type \code{all (x:A) (y:B) ... : RT}

\item Where block \code{ exp where a := aexp; b := bexp; ...}

\end{enumerate}


Note that a where block is just syntactical sugar. The following 2 expressions
are equivalent:
\begin{alba}
    exp where
        a := aexp
        b := bexp
        ...
        z := zexp

    (\ z := (... (\ b := (\ a := exp) aexp) bexp) ...) zexp
\end{alba}
%
i.e. a where term is a function application with a function abstraction at the
position of a function term.

A proper subexpression can appear only in the following positions:
\begin{itemize}

\item Type position

\item Annotated position (an expression with a type annotation)

\item Argument position

\item Function position

\item Definition position (function abstractions and where expressions)
\end{itemize}

From the perspective of term building annotated positions and argument
positions are equivalent, because we always get a required type in these
positions.


In a function position we can only have
\begin{itemize}

\item Identifier

\item Type annotation

\item Function abstraction
\end{itemize}

This is valid, because an expression in a function position must have the type
$\Pi x^A.B$ which cannot be satisfied by all other expressions.







\subsection{Subexpressions in a Function Position}

A subexpression $f$ in a function position is applied to $n$ arguments with $0 <
n$ and has an expected result type $E$ after application to its arguments.

$$
    f\, a_0\, a_1 \ldots a_{n-1} : E
$$

Because of the nature of the function position, no expected type for $f$ is
available.


\subsubsection{Type Annotation \code{exp: T}}

We analyze $T$ in a type position with the expected type $\Any_1$. $T$ must be a
function type. Its decomposition gives the types for the explicit arguments,
generates implicit arguments and a result type which can be unified with the
expected type $E$ of the whole function application.

The inner expresssion \code{exp} can then be analyzed in an annotated position
i.e. with complete expected type. This is practically the same as an expression
in an argument position.

\subsubsection{Identifier}


\subsubsection{Function Abstraction}







\subsection{Subexpressions}

For any subexpression we have a context of the form

$$
\Gamma, \ldots, e^E, \ldots
$$
where $e$ is the hole to be filled with the term for the subexpression.







\subsubsection{Variable $x$}

In case that the expression is a variable $v$ the context has the structure

$$
\Gamma = \ldots, v^V, \ldots
$$

We unify $v^V$ with $E$.

It might be the case that $V$ is not unifyable with $E$ and $V$ is a function
type with implicit arguments $V = \Pi x^A.B$ where $A$ reduces to a kind an $x$
is contained in $B$. In that case we introduce a placeholder $x^A$, form $(v \,
x)^B$ and unify $B$ with $E$. If there are more implicit arguments, the same
procedure can be repeated.









\subsubsection{Function Application $f a$}

We introduce the following placeholders

$$
\Gamma, \ldots, e^E, \ldots, A^{\Any_1}, F^{A\to\Any_1}, a^A, f^{\Pi x^A. F x}
$$
and the constraint
$$
f a \ldots : E
$$
where $\ldots$ are potential implicit arguments, because
the type of $f a$ (which is $F a$) might be a function type starting with implicit
arguments.

If we analyze the syntactic expression for $f$ we get a substitution of the
placeholder $f$ and some unifications involving $A$ and $F$.


Before analyzing the ast for $a$ we might be able to squeeze information out of
the constraint $f a \ldots: E$. This gives useful information if the type of $f
a$ is not a placeholder. Two cases are possible
\begin{enumerate}

\item $E$ is a placeholder: Then assign the type of $f a$ to $E$ and $f a$ to $e$

\item Otherwise: Add potential implicit arguments i.e. form $f a \ldots$ where
$\ldots$ represents the implicit arguments and unify the type of $f a \ldots$
with $E$. Then assign $f a \ldots$ to $e$.

\end{enumerate}


It is possible that the analysis of $f$ and $a$ does not give a lot of useful
information to evaluate the constraint. Consider e.g. the definition of the
union of a set of predicates.

\begin{alba}
    union (pp: Predicate (Predicate Int)): Predicate Int :=
        \x := some p: p x and pp p
\end{alba}

Analyzing $p\,x$ we know that the result must be a proposition i.e. $p\,x:
\Prop$. But $p$ and $x$ are untyped bound variables, therefore no useful type
information is available.  Only $x^A$ where $A^{\Any_1}$ and $p^{\Pi x^A. F x}$
where $F^{A \to \Any_1}$. I.e. we know that $F x$ must be unifyable with $\Prop$
which requires $F := \lambda x^A.\Prop$ i.e. $F: A \to \Prop$ which is ok,
because $A\to\Prop$ is a subtype of $A\to\Any_1$.

The best we can say about $p$ at that point is that is has type $\Pi x^A .
(\lambda x^A. \Prop) x$ wich is equivalent to $A\to\Prop$. Further analysis of
$pp\,p$ will show that its type is $\text{Int}\to\Prop$.








\subsubsection{Function Application with More Arguments $f\, a\, b\, c$}


Function application is left associative. We need placeholders for the
intermediate results.

$$
\underbrace{\underbrace {\underbrace {f \quad a}_g \quad b}_h \quad c}_e
$$


The complete set of placeholders

$$
\begin{array}{ll}
\Gamma, \ldots, e^E, \ldots,

& A^{\Any_1}, a^A, F^{A\to\Any_1}, f^{\Pi x^A. F x}

\\

& B^{\Any_1}, b^B, G^{B\to\Any_1}, g^{\Pi y^B. G y}
\\

& C^{\Any_1}, c^C, H^{C\to\Any_1}, h^{\Pi z^C. H z}
\end{array}
$$
%
and the constraints
$$
\begin{array}{lll}

f \, a \ldots &:& \Pi y^B. G y

\\

g \, b \ldots &:& \Pi z^C. H z

\\

h \, c \ldots &:& E

\end{array}
$$
which must be satisfied before making the substitutions
$$
\begin{array}{lll}
g &:=& f \, a \,\ldots

\\

h &:=& g \, b \,\ldots

\\

e &:=& h \, c \,\ldots
\end{array}
$$
%
and the typing judgements
$$
\begin{array}{lll}

f \, a &:& F \, a

\\

g \, b &:& G \, b

\\

h \, c &:& H \, c
\end{array}
$$


The building of the term consists of the following actions

\begin{enumerate}

\item Analyze the ast of $f$

\item Then do one of the actions for all remaining arguments

    \begin{enumerate}
    \item Satisfy constraint $f \, a \ldots: \Pi y^B. G y$
    \item Set $g := f \, a \ldots$
    \item Analyze the ast of $a$
    \end{enumerate}

    \begin{enumerate}
    \item Analyze the ast of $a$
    \item Satisfy constraint $f \, a \ldots: \Pi y^B. G y$
    \item Set $g := f \, a \ldots$
    \end{enumerate}

\end{enumerate}







\subsubsection{Function Abstraction $\lambda x. t$}



We introduce the following placeholders

$$
\Gamma, \ldots, e^E, \ldots, A^{\Any_1}, x^A, F^{A\to\Any_1},  t^{F x}
$$
%
With these placeholders we get the valid typing judgement
$$
(\lambda x. t) : \Pi x^A. F x
$$
i.e. in order to build the term properly we have to satisfy
$$
\Pi x^A. F x \le E
$$


\begin{itemize}

\item
    If $A$ is given explicitly, we analyze the term and fill the hole $A$ with it.

\item
    If the function abstraction is in a function position, we unify $A$ with the
    type of the corresponding argument.

\item
    If the result type is given explicitly, we analyze it and unify it with $F
    x$.

\item
    If the function abstraction is in a function position and required result
    type is given for the function abstraction applied to the argument $a$, then
    we unify $F a$ with the result type.

\item
    Analze $t$ and fill the hole.
\end{itemize}






\subsubsection{Product Type $\Pi x^A. B$}


$$
\Gamma, \ldots, e^E, \ldots, A^{\Any_1}, x^A, B^{\Any_1}
$$

We first analyze the optional type $A$ and fill the placeholder. Then we analyze
$B$ and fill the placeholder. Then we form $\Pi x^A.B$, unify its type with $E$
and fill the hole $e$. The term $\Pi x^A. B$ must not contain any unfilled holes
starting from $A^{\Any_1}$.

\begin{itemize}

\item If $x$ does not occur in $B$ and the type $A$ is not explicitly given,
then the type $A$ cannot be inferred.

\item Even if $x$ occurs in $B$, it might be the case that $A$ cannot be
inferred. E.g. $\Pi x . \Pi y. x = y$. Since $x$ cannot occur outside the binder,
there is no chance to infer $A$. This case must be reported as an error.

\end{itemize}







\section{Draft}

\subsection{Implicit Arguments}

The syntactic terms do not contain implicit arguments. Implicit arguments are
generated by the compiler.

A term in a function position must have a type which in key normal form looks
like

$$
\Pi \xbold^\Abold . R = \Pi x_0^{A_0} x_1^{A_1} \ldots .\, R
$$

An argument $x_i$ is implicit in the following two cases:

\begin{enumerate}
\item $x_i$ is a proof argument i.e. $A_i : \Prop$ is a valid typing
  judgement.

\item $x_i$ is an inferable type constructor variable i.e. $A_i$ reduces to a
  kind and $x_i$ occurs as a strict subterm in some other $A_j$ which is not a
  proposition (i.e. $A_j:\Any_k$ for some $k$ and $\Any_k$ is the principal
  type of $A_j$) or $x_i$ occurs in the result type $R$.
\end{enumerate}

Note that both cases are mutually exclusive because ``$A_i$ is a proposition''
and ``$A_i$ reduces to a kind'' are mutually exclusive. The type of a kind is
always $\Any_k$ and never $\Prop$.

It is important to see that the types of implicit type variables (or type
constructor variables) are always inferable by unification. Proof: Let's look
at the last implicit type variable $x_m$. By definition it must occur as a
strict subterm either in some type of an explicit variable or in the result
type. By unification we can always assign a type to a variable occuring as a
strict subterm inside of some known types. Having the type of the last
implicit argument, we can infer the type of the previous implicit
argument. Continuing we can infer the types of all implicit non proof
arguments.


Because of the possibility of implicit arguments, a naive unification of
required and actual types does not work. Unification must be coupled
intelligently with term building.

An example illustrates the complexity.

\begin{alba}
  -- constructors for lists
  []:  all A: List A
  (^): all A: A -> List A -> List A

  -- left folding
  fold_left A (a: List A) (B: Any) (f: A -> B -> B) (s: B): B :=
    inspect a case
      [] :=
        s
      h ^ t :=
        fold_left t f (f h s)

   -- list reversal
   reverse A (a: List A): List A :=
     fold_left a (^) []
\end{alba}

Analyzing the term building of the last line we get the following situation:

\begin{itemize}
\item substitution
  \begin{alba}
    B := List A
  \end{alba}
\item required type for $(\caret)$:
  \begin{alba}
    A -> B -> B
  \end{alba}
\item actual type for $(\caret)$:
  \begin{alba}
    all X: X -> List X -> List X
  \end{alba}
\end{itemize}
The required type is a function type with two arguments, the actual type is a
function type with three arguments where the first argument is the polymorphic
argument. Unification is possible only if the first argument of the actual
signature is considered as implicit.


For the constructor $[]$ we have a similar situation. The required type is a
constant (0-ary function type) and the actual type is a function type with one
argument.


Assume that the required signature starts with $n$ implicit arguments and the
actual signature starts with $k$ implicit arguments, then
$$
n \le k
$$
must be satisfied i.e. the required signature must not have more implicit
arguments than the actual signature.

$k - n$ implicit arguments are applied before the unification is done.

Note that if an expression is used in an argument position there is always a
non-dummy required signature.





\subsection{Placeholders}

The term builder uses placeholders for terms/types which it does not yet know.

Placeholders are needed for
%
\begin{enumerate}

\item types of bound variables which do not have an explicit type (a variable
  of type $\Any_1$ will be introduced)

  Restriction: An untyped bound variable has to appear in an argument position
  before it can occur in a function position.

\item inferable implicit arguments (placeholder represents a type or a type
  constructor)

\item proof arguments

\item subterms which have not yet been analyzed

\item expected types if there is no explicit expected type (a variable of type
  $\Any_2$ will be introduced)

\end{enumerate}



During the algorithm we have a set of placeholders and a substitution
$$
\sigma = [x_{i_0}: a_0,\, x_{i_1}: a_1,\, \ldots]
$$
i.e. a list of placeholders/substitution term pairs with the invariant that a
substituted variable must not occur in any substitution term and that the
substituted variables $x_{i_0}, x_{i_1}, \ldots$ are a subset of the
placeholders.





\subsection{Algorithm}

When analyzing a syntatic expression $\text{exp}$ which is applied to $n$
arguments we do this in a context which has a placeholder $e$ representing the
expression applied to its arguments and potentially many more variables which
are either placeholders or bound variables.

$$
\Gamma, \ldots, e^E, \ldots
$$

$E$ is the required result type of the expression applied to its arguments. It
might be a placeholder without substitution if we do not know the expected
result type.

\begin{itemize}

\item Input:
  \begin{itemize}
  \item Context with placeholders an substitutions
  \item Pointer to the placeholder representing the expression applied to its
    arguments.
  \item Number of (explicit) arguments to which the expression is applied
  \end{itemize}

\item Output:
  \begin{itemize}
  \item Context with the placeholder $e$ substituted by a term for the
    expression $\text{exp}$ applied to its arguments and at least $n$ more
    placeholders representing the arguments.
  \item An array of  $n$ pointers to the placeholders for the arguments.
  \end{itemize}
\end{itemize}

Initially analyzing the syntactic expression $\text{exp}$ applied to no
arguments in the context $\Gamma$ we start with the following context and
substitutions
$$
%
\begin{array}{l}
  \Gamma, E^{\Any_2}, e^E
  \\
  \sigma =
  \begin{cases}
    [E : R] & R \text{ is the required type}
    \\
    []      & \text{there is no required type}
  \end{cases}
\end{array}
$$
%
We use $\Any_2$ as the type of $E$ in order to be able to substitute $e$ by
$\Any_0$ and correspondingly $E$ by $\Any_1$.

We expect the algorithm to terminate with a context and substitutions where
the placeholder $e$ has got a substitution.


Now we have to specify the algorithm for the different cases of syntactic
expressions.


\subsubsection{Literals}

There literals for
\begin{itemize}
\item numbers
\item strings
\item characters
\end{itemize}

None of them can accept arguments.

For each of them there is a term which we have to unify with the placeholder.

In case of success we are ready and return an empty array (no arguments).



\subsubsection{Sorts}

In user terms we have only the sorts
\begin{itemize}
\item \code{Any}
\item \code{Proposition}
\end{itemize}

No sort can accept arguments.

I.e. we unify $\Any_0$ or $\Prop$ with the placeholder and return the context
with an empty array.




\subsubsection{Names or Operators}

Names and operators are stored in a string map which return a (possibly empty)
list of variables. Each of the variables has a type.

The type of the variable must not be a placeholder without substitution, if
there are explicit arguments i.e. $n > 0$.

The type of the variable has to be capable to accept $n$ explicit arguments
i.e. it has to have the key normal form $\Pi x^A y^B \ldots . R$ where $x, y,
\ldots$ represent the $n$ explicit arguments plus all implicit arguments which
occur before  the explicit arguments.

Two cases are possible
\begin{enumerate}

\item The expected type $E$ is a type variable without substitution:

  \begin{enumerate}
  \item Substitute $E$ with $R$.

  \item Introduce the placeholders $x, y, \ldots$.

  \item Substitute $e$ by $v x y \ldots$ where $v$ is the variable.

  \item Return the new context with an array pointing to the placeholders of
    the explicits arguments in $x, y, \ldots$.
  \end{enumerate}

\item The expected type $E$ has a signature:

  In that case we have to compare the signatures of $E$ and $R$.

  \begin{enumerate}
  \item $R$ and $E$ start with the same number of implicit arguments:

    \begin{enumerate}
    \item  Unify the signatures of $R$ and $E$.

    \item Introduce the placeholders $x, y, \ldots$.

    \item Substitute $e$ by $v x y \ldots$ where $v$ is the variable.

    \item Return the new context with an array pointing to the placeholders of
      the explicits arguments in $x, y, \ldots$.
    \end{enumerate}


  \item $R$ starts with more implicit arguments than $E$: I.e. $R = \Pi u^U v^V
    \ldots . R'$ where $u, v, \ldots$ are the implicit arguments in $R$ which
    are more than the implicit arguments of $E$.

    \begin{enumerate}
    \item  Unify $R'$ and $E$. Introduce placeholders $x, y, \ldots, u, v, \ldots$.

    \item Substitute $E$ by $v x y \ldots u v \ldots$.

    \item Return the new context with an array pointing to the placeholders of
      the explicits arguments in $x, y, \ldots$.
    \end{enumerate}


  \item $R$ starts with fewer implicit arguments than $E$:

    This is an error condition.

  \end{enumerate}

\end{enumerate}



\subsubsection{Function Application}


\begin{alba}
  f a b c ...             -- normal function application
  a.f b c ...             -- oo style function application
  a + b                   -- operator expression
\end{alba}


\begin{enumerate}

\item Analyze the syntactic expression $f$ which is applied to $n$ arguments
  with a pointer to the placeholder of the whole expression and receive an
  array of $n$ pointers to the placeholders for the arguments.

\item Analyze each syntactic expression for the arguments which are applied to
  $0$ arguments with a pointer to the corresponding placeholder.

\end{enumerate}

There is nothing more to be done, because the first step already generated a
substitution for the placeholder of the whole expression and the subsequence
steps generate substitutions for the placeholders of the arguments.




\vskip 5mm
\subsubsection{Lambda Abstraction}

\begin{alba}
  \ (x: A) (y: B) ... : R := exp      -- fully typed
  \ x y ... := exp                    -- untyped
  (a+)                                -- means \ x := a + x
  (+a)                                -- means \ x := x + a
\end{alba}


\begin{enumerate}
\item Process signature:

  For each formal argument push a placeholder for the type and the bound
  variable onto the context to get
  $$
  \Gamma, \ldots, e^E, \ldots, A^{\Any_2}, x^A
  $$

  If there is an explicit type, analyze the syntactic expression for the type
  with a pointer to $A$.

  After pushing all arguments push a placeholer for the result type and a
  placeholder for the inner expression onto the context to get

  $$
  \Gamma, \ldots, e^E, \ldots, A^{\Any_2}, x^A, \ldots, R^{\Any_2}, f^R
  $$

  If there is an explicit result type, analyze the syntactic expression for the
  result type with a pointer to $R$.


\item Find prefix of the formal arguments which correspond to the $n$
  arguments to which the lambda abstraction is applied.

  Scan the formal arguments left to right skipping all implicit arguments
  until $n$ explicit arguments are found. Assume that $u$ is the first
  argument which does not correspond to an explicit argument.

  $$
  \Gamma, \ldots, e^E, \ldots, A^{\Any_2}, x^A, \ldots, u^U, \ldots, R^{\Any_2}, f^R
  $$

\item Exploit the information of the expected result type $E$, if possible.

  \begin{enumerate}
  \item The expected result type $E$ is an unsubstituted placeholder

    TBD

  \item The expected result type $E$ is not an unsubstituted placeholder

    Analyze the signature of $E$.

    In the remaining formal arguments of the lambda abstraction (i.e. starting
    from $u$ skip all implicit arguments until there are not more implicit
    arguments than in the signature of $E$.

    Unify the remaining formal arguments of the lambda abstraction with the
    signature of $E$.
  \end{enumerate}


\item Analze $\text{exp}$ with a pointer to $f$.

\item Substitute placeholders

  During the analysis all placeholders for the types of the bound variables
  must have received substitutions which do not contain placeholders to the
  right of $A$ (the placeholder for the type of the first formal argument).

  If this is not the case, the type of the corresponding bound variable cannot
  be inferred completely which is an error condition.

  There might remain some other placeholders to the left of $A$ which do not
  have substitutions. However these placeholders do not occur in the
  substitutions of the placeholders for the types of the formal arguments.

  We eliminate all placeholders having substitutions (except $f$ and $R$) by
  replacing them by their substitutions and move all placeholders without
  substitutions to the left of the bound variables resulting in
  $$
  \Gamma, \ldots, e^E, \ldots, x^{A'}, y^{B'} \ldots, R^{\Any_2}, f^R
  $$

\item Generate the lambda abstraction applied to the arguments

  If $E$ is a placeholder without substitution we add the substitution $\Pi
  x^{A'} y^{B'} \ldots . R$ (replacing $R$ by its substitution).

  Generate placeholders $x, y, \ldots$ for the formal arguments including all
  formal arguments corresponding to explicit actual arguments and the skipped
  implicit arguments.

  Substitute $e$ by ($\lambda x^{A'} y^{B'} \ldots . f) x y \ldots$ (using the
  substitution of $f$).

  Return pointers to the part of $x, y \ldots$ which correspond to the
  explicit actual arguments.

\end{enumerate}





\vskip 5mm
\subsubsection{Function Type}


\begin{alba}
  all (x: A) (y: B): R                -- fully typed
  all x y: R                          -- untyped
\end{alba}
TBD

\vskip 5mm
\subsubsection{Fixpoint}

\begin{alba}
  f (x: A) (y: B) ... : R := exp
  f x y ... := exp
\end{alba}

TBD

\vskip 5mm
\subsubsection{Pattern Match}

TBD











\subsection{Example}




\subsubsection{Example with Polymorphism}


We want to analyze the syntactic term

\begin{alba}
  all a: reverse (reverse a) = a
\end{alba}

in the context
$$
\Gamma = [e^{\Pi A^\Any. A \to A \to \Prop}, L^{\Any\to\Any}, r^{\Pi A^\Any. L A \to L A}]
$$
where $e$ is an abbreviation for $=$ and $r$ is an abbreviation for
\code{reverse}

For all unkown types and not yet analyzed arguments we introduce substitutable
variables and let unification instantiated them. Step by step we get the
following new contexts and partially analyzed terms.
$$
\begin{array}{lll}
  \Gamma, A^\Any, a^A, B^\Any, u^B, v^B
  & \vdash
  & e B u v : \Prop

  \\

  \Gamma, A^\Any, a^A, B^\Any, u^B, v^B, C^\Any, w^{L C}
  & \vdash
  & e B (r C w) v : \Prop

  \\

  \Gamma, A^\Any, a^A, B^\Any, u^B, v^B, C^\Any, w^{L C}, D^\Any, x^{L D}
  & \vdash
  & e B (r C (r D x)) v : \Prop

  \\

  \Gamma, A^\Any, a^A, B^\Any, u^B, v^B, C^\Any, w^{L C}, D^\Any, x^{L D}
  & \vdash
  & e B (r C (r D a)) v : \Prop

  \\

  \Gamma, A^\Any, a^A, B^\Any, u^B, v^B, C^\Any, w^{L C}, D^\Any, x^{L D}
  & \vdash
  & e B (r C (r D a)) a : \Prop
\end{array}
$$
%
We don't have a type for $a$, therefore we introduce the type variable
$A$. Then we can introduce the variable $a$ of type $A$. The variable $a$ is
not substitutable.

Equality $e$ needs a type and two elements to compare. For the type we
introduce $B$ and for the elements to compare we introduce $u$ and $v$.

List reversal $r$ needs an element type and a list to reverse. For the
element type we introduce $C$ and for the list to reverse we introduce
$w$. The outer reversal returns the type $L C$ which we unify with $B$


For the inner reversal we introduce $D$ and $x$. The result type of the inner
reversal is $L D$ which we unify with $L C$ which is the argument type of the
outer reversal.

Finally we associate $x$ and $v$ with $a$ which requires the unification of
$A$ with $L D$ and $A$ with $B$.



The following substitutions are produced by analysis of arguments and
unification.
$$
\begin{array}{llll}
  u & := & r C w  &\quad  B = L C
  \\
  B & := & L C
  \\
  w & := & r D x  &\quad  L C = L D
  \\
  C & := & D
  \\
  x & := & a      &\quad  A = L D
  \\
  A & := & L D
  \\
  v & := & a      &\quad  A = B
\end{array}
$$
%

Substitutable variables in the order of introduction and their substitutions
and final substitutions.
$$
\begin{array}{llll}
  A^\Any &:=& L D
  \\
  B^\Any &:=& L C    &\quad L D
  \\
  u^B   &:=& r C w  &\quad  r D (r D a)
  \\
  v^B    &:=& a
  \\
  C^\Any &:=& D
  \\
  w^C    &:=& r D x &\quad  r D a
  \\
  D^\Any
  \\
  x^{L D} &:=& a
\end{array}
$$

$D$ is the only substitutable variable which remains unsubstituted. Shifting
$D$ down and doing all substitutions we get
$$
\Gamma, D^\Any, a^{L D} \vdash e (L D) (r D (r D a)) a : \Prop
$$
%
and finally
$$
\Gamma \vdash \Pi D^\Any a^{L D} .\, e (L D) (r D (r D a)) a : \Prop
$$
%


We can generate a function expression
$$
\Gamma \vdash \lambda A a B u v C w D x. e B u v
: \Pi A^\Any a^A u^B v^B C^\Any w^{L C} D^\Any x^{L D}
$$


Introduce two new variables $D$ and $a$ and evaluate the function expression
$$
\Gamma, D^\Any, a^{L D} \vdash (\lambda A a B u v C w D x. e B u v) (L D) a (L
D) (r D (r D a)) a (r D a) : \Prop
$$
which as above results in
$$
\Gamma, D^\Any, a^{L D} \vdash e (L D) (r D (r D a)) a : \Prop
$$
and finally in
$$
\Gamma \vdash \Pi D^\Any a^{L D} .\, e (L D) (r D (r D a)) a : \Prop
$$


\subsubsection{Restrictions to Reduce Complexity}

We do not allow
\begin{alba}
  double_reversal: all a: reverse (reverse a) = a
\end{alba}

because the polymorphic type argument of \code{reverse} cannot be inferred.
All arguments must be explicit. Only the following expression is valid

\begin{alba}
  all (A: Any) (a: List A): reverse (reverse a) = a
  -- or shorter
  all A (a: List A): reverse (reverse a) = a
\end{alba}


Other example:

\begin{alba}
  all n a: sum (n ^ a) = n + sum a
\end{alba}
in the context
$$
\Gamma = [
e^{\Pi A^\Any. A\to A\to\Prop},
\Natural^\Any,
p^{\Natural\to\Natural\to\Natural},
L^{\Any\to\Any},
c^{\Pi A^\Any. A \to L A \to L A},
s^{L \Natural \to \Natural}
]
$$


$$
\begin{array}{lll}
  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C
  & \vdash
  & e C x_0 x_1 : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural}
  & \vdash
  & e C (s x_2) x_1 : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural},
  D^\Natural, x_3^D, x_4^{L D}
  & \vdash
  & e C (s (c D x_3 x_4) x_1 : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural},
  D^\Natural, x_3^D, x_4^{L D}
  & \vdash
  & e C (s (c D n a) x_1 : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural},
  D^\Natural, x_3^D, x_4^{L D}, x_5^\Natural, x_6^\Natural
  & \vdash
  & e C (s (c D n a) (p x_5 x_6) : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural},
  D^\Natural, x_3^D, x_4^{L D}, x_5^\Natural, x_6^\Natural,
  x_7^{L\Natural}
  & \vdash
  & e C (s (c D n a) (p x_5 (s x_7) : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural},
  D^\Natural, x_3^D, x_4^{L D}, x_5^\Natural, x_6^\Natural,
  x_7^{L\Natural}
  & \vdash
  & e C (s (c D n a)) (p n (s a)) : \Prop

\end{array}
$$
%

During the term building the following substitutions are produced
$$
\sigma = \left[
\begin{array}{ll}
  C:=\Natural
  \\ x_0:= s x_2      & x_0 := s (c \Natural n a)
  \\ D:=\Natural
  \\ x_2:=c D x_3 x_4 & x_2 := c \Natural n a
  \\ A := D           & A := \Natural
  \\ x_3 := n
  \\ B := L D         & B := L \Natural
  \\ x_4 := a
  \\ C := \Natural
  \\ x_1 := p x_5 x_6 & x_1 := p n (s a)
  \\ x_6 := s x_7     & x_6 := s a
  \\ x_1 := n
  \\ x_7 := a
\end{array}
\right]
$$



\subsubsection{Discussion of Simplification}


The simplification discussed in this section is
\begin{quote}
  At the end of term building all placeholders must have
  substitutions. Clearly all substitutions must not contain placeholders. The
  latter is guaranteed by the unification algorithm.
\end{quote}

In order to make no invalid substitutions we have to guarantee that no
substitution contains non-placeholder variables above the corresponding
placeholder. In the above example the only non-placeholder variables are $n$
and $a$. These two variables are contained only in the substitutions of the
placeholders which represent subterms. The reason for the substitutions is
that the variables occur within the terms.

Variables occuring in terms are be introduced before the placeholders
representing the subterms. Therefore it seems obvious that the variables can
occur only in placeholders representing subterms with the correct ordering.

The critical question is: Since the variables $n$ and $a$ are untyped, we
introduced the placeholders $A^\Any$ and $B^\Any$ representing the types of
$n$ and $a$ before the variables $n$ and $a$.
\begin{quote}
  Can the substitutions of $A$ and $B$ contain the variables $n$ and $a$?
\end{quote}
Hopefully not, because this would indicate some circularity. A variable must
never be contained in its own type!!!

The placeholders $A$ and $B$ get their substitutions only at places where the
corresponding variables $n$ and $a$ are used and therefore the placeholders
must be unified with the corresponding required types for $n$ and $a$. It is
very difficult to imagine how the variables $n$ and $a$ could \emph{creep
  into} the corresponding required types. This would mean that $n$ and $a$ had
been used within the forming of the required types i.e. they would have been
used before and would have already substitutions.

I.e. $A$ and $B$ get their substitutions at the first use of $n$ and $a$. If
$n$ and $a$ are arguments, their required types cannot contain the variables.

Remains the possibility that untyped variables occur in function positions. At
the moment I cannot imagine a useful situtation. It might be best to forbid
the occurrence of untyped variables in a function position and restrict the
occurrence of untyped variables to argument positions. This restriction
certainly avoids circularity.


\noindent Restrictions:
\begin{itemize}

\item All placeholders must get substitutions during term building. Otherwise
  the user is asked to provide some typing annotation or provide some type
  variables.

\item No untyped variable can occur in a function position before it has
  occurred in an argument position.

  Possible relaxation of the restriction: If an untyped variable occurs at
  least in an argument position, then the subterm where it occurs in an
  argument position is analyzed first. However this adds complexity which is
  not worth the effort.
\end{itemize}



\subsubsection{Untyped Arguments in Function Position}

What needs to be done if we allow untyped bound variables in function
positions. First we need a type variable i.e. a placeholder for the type.
$$
\Gamma, A^\Any, f^A, \ldots
$$
On the first occurrence of $f$ in a function position we have to introduce two
new type variables
$$
\Gamma, A^\Any, f^A, \ldots, B^\Any, C^\Any
$$
and do the unification $ A = \Pi x^B. C$ where $B$ cannot depend on $x$ and
$C$ can depend on $x$.

We see a difficulty here. There is no variable $x$ in the context.

\noindent Next difficulties:

$f$ could occur in different function positions with
different number of arguments.

There is no way to find the implicit arguments of the application.

Therefore: We allow untyped arguments only in function positions if they occur
before in argument positions. If they occur in argument positions, then we
have a type for the variable which is not inferable (because it is explicit)
and therefore can be analyzed for arity.


\begin{alba}
  -- legal
  union A (ps: Predicate (Predicate A)): Predicate A :=
    \ x := some p: ps p and p x  -- 'p' occurs first in argument position

  -- illegal
  union A (ps: Predicate (Predicate A)): Predicate A :=
    \ x := some p: p x and ps p   -- 'p' occurs first in function position

  -- legal with explicit type
  union A (ps: Predicate (Predicate A)): Predicate A :=
    \ x := some (p: Predicate A): p x and ps p
\end{alba}









%


\subsection{Requirements}

The input to the term builder:
%
\begin{enumerate}

\item A syntactic term from the source code

\item A context

\item An optional expected type
\end{enumerate}

Output of the term builder: Because of ambiguities the output is a list of the
following data
%
\begin{enumerate}

\item A term in the intermediate language whose type is the optional expected
  type.

\item An augmented context which contains in addition to the input context
  \begin{enumerate}
  \item Type variables which can be freely substituted with any type without
    disturbing the validity of the term. If there are free type variables the
    term is polymorphic. E.g. the term \code{nil A} has the free type variable
    \code{A:Any}. The user only writes \code{nil} but the term builder has to
    add the implicit argument. Since there is no way to determine it, it has
    to assume a type variable.
  \item Proof variables which are used in the term and which have to be
    substituted by the prover by concrete proofs.
  \end{enumerate}
\end{enumerate}


The required type of a syntactic term depends on where the term is positioned.
%
\begin{description}

\item[Top of the Repl]
  %
  The term does not have a required type. It can be anything: A type, an
  object, a sort, ...

\item[Type Annotation]
  %
  Examples:
  \begin{alba}
     reverse (A: Any) (l: List A): Specified (\r := r.is_reversal_of l)
       := ...

     \ (n:Natural): Natural := n + 1
  \end{alba}
   %
   In these examples all terms to the right of the colon \code{:} must be
   types. There is no requirement for the types except that they must be types
   i.e. their types must be sorts. Since we have no required type, we cannot
   introduce a variable to represent them.

 \item[Term with Type Annotation]
   %
   In the example
   \begin{alba}
     (3 + 4 / 8 * 3 : Natural) = list.length
   \end{alba}
   the term \code{3 + 4 / 8 * 3} has the type annotation
   \code{Natural}. Therefore the type annotation \code{Natural} is the
   required type for the term.

 \item[Function Definition]
   %
   If the term is the defining expression of a function definition and the
   result type of the function is specified, then the required type of the
   defining expression is the result type of the function.
   %
   \begin{alba}
     f (a:A) (b:B): R := exp
   \end{alba}

 \item[Argument]
   %
   An argument must be an argument of some function expression. The function
   expression has a type which clearly indicates the required types for the
   arguments. Therefore a syntactic expression in an argument position has a
   required type and we can introduce variables to represent the argument
   terms which we later substitute by the corresponding intermediate language
   terms.

 \item[Function]
   %
   In the syntactic term \code{f a b} the subterm \code{f} is in the function
   position. The required type of the whole expression is a required type for
   the return type of \code{f} i.e. the subexpression in the function
   position. Another requirement for the subterm \code{f} is that must be
   applicable to $n$ arguments.
\end{description}



\noindent In summary we have the requirements for a syntactic term
%
\begin{enumerate}

\item Required result type, which is either
  \begin{enumerate}

  \item nothing in the case of a toplevel expression in the repl

  \item some type, if the term is in a type annotation position (to the right
    of a colon)

  \item result type of a function definition or annotated type of an expression

  \item the type of a variable which has been introduced to represent the
    argument
  \end{enumerate}


\item Number of essential arguments (without implicit arguments and proof
  arguments). If the number of arguments is different from zero, then the term
  is in a function position.
\end{enumerate}







%
\subsection{Algorithm Data}


\noindent Input:

\begin{enumerate}

\item Nonempty list of

  \begin{enumerate}

  \item Context

  \item Set of all placeholders / Substitution

  \item Stack of placeholders representing not yet analyzed function arguments

  \item Number of arguments (to which the syntactic expression is applied) and
    the application mode (normal, target of object call, operand)

  \item Optional expected type
  \end{enumerate}

\item Syntactic expression
\end{enumerate}

Lists are needed because of ambiguity. All elements of the list have the same
number of arguments. If there is an expected type, there is one for all
elements. If the expected type is an arbitrary type, it is the same for all
list elements.

If no error occurs, then the algorithm outputs a nonempty list of:

\begin{enumerate}

\item Context

\item Set of all placeholders / Substitution

\item Stack of placeholders representing not yet analyzed function arguments

\item Term and its type in the intermediate language

\end{enumerate}

The context, set of placeholders, substitution and the stack of placeholders
are common elements of the input and output structure.






\subsection{Apply Terms to Arguments}
\label{sec:apply-terms-to_arguments}



Input: Number of explicit arguments, Expected type(s) of term applied to
arguments, list of term/type pairs of the term under consideration.

Every syntactic subterm might be applied to some arguments.

The analyis of the term returns a list of term/type pairs.

We analyze the types and get a list of argument descriptors where each
descriptor indicates what kind of argument it is: Proof argument, explicit
argument, implicit type constructor argument.

We introduce placeholders $a_0, a_1, \ldots$ for the explicit arguments
occurring in the syntactic term and all implicit arguments before, between and
after the actual explicit arguments.

Compute the type $T$ of the term
$$
t \, a_0 \, a_1 \, \ldots : T
$$
and unify it with the expected types. The expected type(s) do not contain any
placeholders which have been introduced in the analyis of the term $t$.

If unification is not successful or if the type of $t$ does not allow
sufficient arguments, then the term $t$ is not possible in that position.

If at the end no candicates remain, then a type error message has to be
generated.

Two kinds of error messages can be generated from this phase:
\begin{enumerate}
\item None of the terms can be applied to $n$ explicit arguments

\item There are some terms which can be applied to $n$ explicit arguments but
  the result type matches non of the expected types.
\end{enumerate}







\subsection{Terminal Elements}

The possible terminal elements (syntactic terms which have no subterms) of a
syntactic term are
%
\begin{enumerate}

\item Identifier / Operator

\item Number

\item Character

\item String

\item Sort (\code{Proposition} and \code{Any})
\end{enumerate}

Numbers, characters, strings and sorts cannot be applied to
arguments. Identifiers, operators and numbers can have ambiguous types.

The expected type is the type of the expression applied to the arguments.

\begin{enumerate}

\item Get a list of term/type pairs. Examples
  \begin{itemize}

  \item 125: [125:Natural, 125:Nat, 125:Int, 125:Float, 125:Byte]

  \item 'a': ['a':Character, 'a':Byte]

  \item ``Hello'': [``Hello'':String, ``Hello'':Byte\_string]

  \item (+): [(+):$\Natural\to \Natural\to \Natural$, (+): String $\to$ String
    $\to$ String, ...]

  \item reverse: [reverse: all A: List A $\to$ List A]

  \item $\Prop$: [$\Prop:\Any_0$]

  \item $\Any$: [$\Any_0:\Any_1$]

  \end{itemize}

\item Apply arguments.
\end{enumerate}



\subsection{Function Application}

A function application has the forms

\begin{alba}
  f a b c ...        -- normal mode

  a.f b c ...        -- oo style mode

  a binop b          -- operator expression
\end{alba}


\begin{enumerate}

\item Analzye $f$ and get $f x y \ldots$ and the placeholders on the stack
  which represent the arguments.


\item For each argument $a_i$ do
  \begin{enumerate}

  \item Pop one placeholder $(x_i,A_i)$ off the stack and use $A_i$ as a
    required type for $a_i$.

  \item Analyze $a_i$ with zero arguments and get the corresponding term
    $t_{a_i}$ as a result.

  \item Substitute $x_i$ with $t_{a_i}$.

  \end{enumerate}

\item Return $f x y \ldots$.

\end{enumerate}






\subsection{Function Term / Abstraction}

A function term has the possible forms

\begin{alba}
  \ x y ... := exp                     -- without types

  \ (x:A) (y:B) ... : R := exp         -- fully typed

  (a +)                                -- section '\x := a + x'

  (+ a)                                -- section '\x := x + a'
\end{alba}


For unknown argument types we have to introduce type variables into the context.

For
\begin{alba}
  \ x y (z:C) := exp
\end{alba}
%
we need the context
$$
    \Gamma, A^{\Any_1}, x^A,  B^{\Any_1}, y^B, z^C \ldots
$$
%
where the two placeholder type variables $A$ and $B$ have been introduced to
describe the types of the variables $x$ and $y$.

The type $C$ might contain the variables $x$ and $y$ (e.g. \code{C = x < y})
i.e. the analysis of $C$ might already determine the type variables $A$ and
$B$.

Finally we analyze the expression \code{exp} in the new context and get an
intermediate language term $e:E$ in the context.

At the end some unassigned type variables can remain. We shift them all to the
left of $x:A$ and form $\lambda x^A y^B z^C . e : \Pi x^A y^B z^C . E$ in the
context below $x$.

During the analysis of \code{exp} it is possible that some proof variables
like $x_p:p$ have been introduced. The actual proof has not yet been
generated, but it might depend on $x,y,z$. In order to eliminate $x_p$ we
introduce a new proof variable $y_p:\Pi x^A y^B z^C . p$ to the left of $x:A$
and substitute $x_p$ by $y_p x y z$.

Now we analyze $\Pi x^A y^B z^C . E$ with respect to the number of variables
to which the function term is applied and unify the result type with the
expected type.



A function term might be potentially recursive
\begin{alba}
  f x y := exp
\end{alba}
where \code{f} might occur in \code{exp}

In that case we need a context like
$$
  \Gamma, A^{\Any_1}, B^{\Any_1},  R^{\Any_1}, f^{\Pi x^A y^B.R}, x^A, y^B
$$
%
to analyze \code{exp} with the expected type $R$.

Suppose $e:E$ is the result of the analysis of \code{exp} and $f$ occurs in
$e$. Then we have to find the decreasing argument which decreases in each
recursive call.

There is a special case that each usage of $f$ is a function call with fewer
arguments than there are formal arguments in the declaration \code{f x
  y}. That case has to be investigated more in detail (TBD!!).

In case of success the result of the analysis of the function expression is
$\fix(f^{\Pi x^A y^B. R}, e, k) : \Pi x^A y^B. R$.





\subsection{Function Type}


\begin{alba}
  all x y ... : exp

  all (x:A) (y:B) ... : exp

  all (x:A) : B -> ... -> Z        -- all (x:A) (_:B) ... : Z
\end{alba}

If there is an expected type for the whole expression, then it must be a sort
i.e. either $\Prop$ or $\Any$ because an expression of the form \code{all x
  y:exp} is always a type and the type of a type is a sort.

As in the analysis of a function term we have to introduce type variables for
the untyped variables into the context.
$$
\Gamma, A^{\Any_1}, x^A, B^{\Any_1}, y^B, \ldots
$$
%
In this context we analyze \code{exp} expecting some type (note that
\code{exp} is to the right of a colon) or $\Prop$ if the expected type of the
whole expression is $\Prop$.





\vskip 5mm
\subsection{Let and Where Constructs}



\begin{alba}
  exp where               -- 'exp' can contain 'a' and 'b'
    b x y := bexp         -- 'bexp' can contain 'a' (and 'b')
    a z := aexp           -- 'aexp' does not contain 'b', but maybe 'a'

  -- or
  let
    a z := aexp
    b x y := bexp
  in
    exp

  -- equivalent to
  (\a := (\b := exp) (b x y := bexp)) (a z := aexp)

  -- reduces to
  exp[a:=aexp][b:=(b x y := bexp)[a:=(a z := aexp)]]
\end{alba}

Only if \code{b} does not contain \code{a} we have the following equivalent
expression.

\begin{alba}
  (\a b := exp) (a z := aexp) (b x y := bexp)

  -- reduces to
  exp[a:=(a z := aexp)][b:=(b x y := bexp)]
\end{alba}



\vskip 5mm
\subsection{Pattern Match}

\begin{alba}
  inspect
    e
  case
    p1 := r1
    p2 := r2
    ...
\end{alba}


\vskip 5mm
TBD
\vskip 5mm




\newpage

\subsection{Unification}

We introduce placeholders for

\begin{enumerate}

\item Proof arguments in function applications.

\item Inferable type (or type constructor) variables in function applications.

\item Types of untyped variables in binders ($\lambda x^A . e$, $\Pi x^A
  . B$). Both need a type variable $A^{\Any_1}$. The type of the variable $A$
  is introduced as $\Any_1$ in order to be able to instantiate $A$ with
  $\Prop$ or $\Any_0$.

  The type variable $A$ will be instantiated if $x$ occurs as a proper subterm
  in $e$ or $B$ or if $\lambda x . e$ has a required type which is not a
  placeholder.

\end{enumerate}


The unification might add to the vector of substitutions
$$
\sigma = [y_0 : a_0, y_1 : a_1, \ldots]
$$
where $y_i$ are placeholders. Each placeholder $y_i$ is a variable $x_j$ in
the context. Placeholders which have a substitution can be eliminated from the
context.

Invariant: Substitutions $a_i$ of the placeholder $y_i$ which is the variable
$x_j$ must not contain variables $x_k$ with $j \le k$. This consistency
condition guarantees that no type in the context contains \emph{future}
variables after substitution.


The substitution lemma
$$
\rulev
{
  \Gamma,x^A,\Delta \vdash t : T
  \\
  \Gamma \vdash a: A
}
{\Gamma, \Delta[x:=a] \vdash t[x:=a] : T[x:=a]}
$$
is the theoretical foundation. I.e. each substitution must be valid in the
context before the placeholder variable.





\newpage
\section{Type Inference (Old material)}

\subsection{Basics}

A global (constant or function) is uniquely found by its name and its
signature. Many globals can share the same name as long as their signature is
different.

Looking up the name results in a list of globals. If the list is empty, then a
global with that name does not exist.

Locals shadow all previously declared names. I.e. either one local or a list
of globals is returned by looking up a name.

In an expression a name is used with a certain number of essential arguments
(i.e. with an arity at its call site). This has to be compared with the actual
arity. The actual arity must be sufficient for the required arity at the call
site.

If the arity is sufficient, the formal arguments can be pushed into the
context and a type remains as the result type which must be unified with the
required result type (possibly instantiating substitutable type variables).


\paragraph{Look up a global} It is a function call with $n$ essential
arguments. The $n$ arguments and the corresponding type variables and proof
arguments can be extracted and pushed into the \emph{global} context with
dummy variables. If the global is not unique we get more than one context. The
context might have different inferable variables and different types for the
dummy variables.

\paragraph{Required types}
If it is explicitly given (result type of a function in a function definition
or explicitly typed expression), then it is only one type and not a set of
types.

If the expression is used as an argument of a function, then there can be
multiple required types. Anyhow, we have a context (or a set of contexts) and
for each context an explicit type or a pointer to an argument (whose type is
the required type).




\subsection{Unification}


A system of equations is in a \emph{solved form} iff it has the following
properties
%
\begin{enumerate}

\item All equations have the form $x = t$ where $x$ is a variable.

\item A variable that occurs on the left-hand side of an equation does not
  occur at the right-hand side of any equation.

\item A variable may occur only on one left-hand side.
\end{enumerate}

The system
$$
%
\begin{array}{lll}
  x &=& f\, y
  \\
  y &=& g\, x
\end{array}
$$
%
can be made inconsistent by substituting the second equation into the first
getting $x = f (g\, x)$ where $x$ occurs on the left and on the right-hand side.

The system
$$
\begin{array}{lll}
  x &=& f\, y
  \\
  y &=& g\, z
  \\
  z &=& c
\end{array}
$$
%
where $c$ does not contain any variables can be transformed into the solved
form
$$
\begin{array}{lll}
  x &=& f\, (g \, c)
  \\
  y &=& g\, c
  \\
  z &=& c
\end{array}
$$
%
because it has no circularity.

The non-circularity can be maintained easily on a system in solved
form. Assume we have
$$
%
\begin{array}{lll}
  x &=& t_x
  \\
  y &=& t_y
\end{array}
$$
%
in solved form (i.e. $t_x$ and $t_y$ contain neither $x$ nor $y$) and we want
to add a new equation $z = t_z$. We just use
$$
%
\begin{array}{lll}
  x &=& t_x[z := t_z]
  \\
  y &=& t_y[z := t_z]
  \\
  z &=& t_z[x,y := t_x, t_y]
\end{array}
$$
%
and check if any of the variables occurs on the right-hand side of its
equation. The system remains consistent if $t_z$ does not contain $x,y$ or if
$t_x,t_y$ do not contain $z$.


Question: Is it possible to avoid circularity without transforming the system
into the solved form on each step? Let's assume we have
$$
%
\begin{array}{lll}
  x &=& t_x
  \\
  y &=& t_y
\end{array}
$$
%
which is solvable i.e. $t_x$ does not contain $y$ or $t_y$ does not contain
$x$ and we want to add a new equation $z = t_z$. $z$ might be contained in
$t_x$ and/or $t_y$ and $x$ or $y$ might be contained in $t_z$.




\subsection{Type Safe Unification}

Since we have a well typed system it might be possible that circularity during
unification is impossible due to the typing rules.

Assume that $A$ is a type variable and during unification we get the equation
$A = L\, A$ where $L$ is any type constructor (e.g. \code{List}). Since we can
substitute equals for equals we would get the infinite chain
$$
  A = L\, A = L\, (L\, A) = L\, (L\, (L\, A)) \ldots
$$



Example: We want to build a term for the syntactic expression $a + b * c$ in
the context $\Gamma$. This is possible only if the variables $a, b, c, +, *$
occur in $\Gamma$ i.e. we assume a context
$$
\Gamma = [+^{I\to I\to I}, *^{I\to I\to I}, \ldots, a^I, b^I, c^I, \ldots]
$$


We don't know the type of the expression nor a term which
represents the expression. We add two unknows (i.e. variables) to the context.
%
$$
\Gamma, E^\Any, e^E
$$
%
Now we have to analyze $\cdot + \cdot$ as a binary operator i.e. a function
with two arguments. In the context we have $+^{I \to I \to I}$ where $I$
represents the type of integer numbers.

We need a placeholder of type $I$ for each argument and get
$$
%
\Gamma,  E^\Any, e^E, u^I, v^I \vdash u + v: I
$$
%
We unify $e^E$ with $(u+v)^I$ and get the system
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
\end{array}
$$
%
Next we analyze the expression $a$ which is not a function call and therefore
does not need new placeholders.
$$
%
\Gamma,  E^\Any, e^E, u^I, v^I \vdash a:I
$$
%
Unification of $u^I$ and $a^I$ leads to
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
\end{array}
$$
%
Next we analyze $\cdot * \cdot$ and need again two new placeholders
$$
%
\Gamma,  E^\Any, e^E, u^I, v^I, w^I, x^I \vdash w * x: I
$$
%
and unify $v^I$ with $ (w * x)^I$ to get
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
  \\
  v &=& w * x
\end{array}
$$
%
Continuing the process we finally get
$$
%
\Gamma,  E^\Any, e^E, u^I, v^I, w^I, x^I
$$
%
with
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
  \\
  v &=& w * x
  \\
  w &=& b
  \\
  x &=& c
\end{array}
$$
%
This system can be resolved into
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& a + b * c
  \\
  u &=& a
  \\
  v &=& b * c
  \\
  w &=& b
  \\
  x &=& c
\end{array}
$$
%
where only the first two lines are interesting.





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main_alba_design"
%%% End:
