\section{Term Building}


\subsection{Task}

The intermediate language of Alba is strictly typed. All bound variables need
explicit types, calls of polymorphic functions need type arguments and
propositions need proofs.

The language for the user is much more liberal, otherwise it would be very
tedious to write programs in Alba.

The task of term building is to fill the gaps between the user language and
the intermediate language.





\begin{description}

\item[Binders]
  %
  The user can write in program text
  \begin{alba}
    \ x y := e

    all x y: p
  \end{alba}
  and the term builder has to generate $\lambda x^A y^B. e$ and $\Pi
  x^A y^B  . p$ i.e. it has to infer the argument types.


\item[Implicit Type Arguments]
  %
  Polymorphic functions and constructors need type arguments in the
  intermediate language. In order to construct an empty list the constructor
  $\text{nil}$ receives the object type as an argument. The user does not
  provide this information. Therefore the source code terms
  \begin{alba}
    1 ^ 2 ^ []           -- [] is nil and (^) is cons

    reverse list
  \end{alba}
  %
  have to be transformed to
  $$
  \begin{array}{l}
    \text{cons}\, \Natural\, 1 \,(\text{cons}\, \Natural\, 2\, (\text{nil}\,
    \Natural))

    \\

    \text{reverse}\, \text{String} \, \text{list}
  \end{array}
  $$


\item[Implicit Proof Arguments]
  %
  The user does not supply explicit proof arguments. Let's assume we have the
  function definition
  \begin{alba}
    predecesssor (n:Natural): 0 < n -> Natural := ...
  \end{alba}
  %
  i.e. a function that can be called only with a nonnegative argument. Then
  the user can call the function with
  \begin{alba}
    predecessor n
  \end{alba}
  %
  The term builder does not generate the actual proof. This is the task of the
  prover. But the term builder generates an new variable for the missing proof
  (e.g. $p: 0 < n$) and generates the term $\text{predecesssor n p}$ in the
  intermediate language.

  Proof arguments are implicit only for functions whose result type is not a
  proposition. If the result type of a function is a proposition, then the
  proof arguments must be provided explicitly. If the user wants the prover to
  find the prove, then it is possible to write the wildcard \code{\_} instead
  of an explicit argument.


\item[Specified Type Splitting]
  %
  In Alba we have the specified type which is a simple type plus a
  specification which objects of that simple type must satisfy in order to be
  objects of the specified type. The specified type is defined as an inductive
  type
  %
  \begin{alba}
    class Specified (A:Any) (f:A -> Proposition): Any create
      specified (a:A): f a -> Specified f
  \end{alba}
  %
  We use the convention that an argument of a function never has a specified
  type. The simple type and the proposition must be separate arguments. But
  objects of specified type can be returned from functions (e.g. a number with
  a proof of the fact that it is a prime number).

  The term builder splits return values of specified type into simple values
  and proof values by using projections. The simple value is fed as an
  argument and the proof value is shifted into the context and can be used by
  the prover.

  The term builder uses the projection functions
  \begin{alba}
     value (A:Any) (f:A -> Proposition) (v:Specified f): A :=
       inspect v case
         specified a := a

     proof (A:Any) (f:A -> Proposition) (v:Specified f): f (value v) :=
       inspect v case
         specified _ p := p   -- result type of 'proof' is a proposition
                              -- therefore explicit proof arguments
  \end{alba}
  %
  Note that \code{A} and \code{f} are implicit type arguments for both
  functions. Therefore the user can call them by writing \code{value v} and
  \code{proof v}.


\item[Elimination Function]
  %
  The pattern match construct
  $\case(e, \lambda \ybold^\Abold x^T . R, \fbold)$ needs an elimination
  function $\lambda \ybold^\Abold x^T . R$ mapping the indices of the
  inductive type and an object of the inductive type into the result type of
  the pattern match expression (i.e. the term $R$ can depend on $\ybold$ and
  $x$).
  %
  \begin{alba}
     (<=) (a b:Natural): Decision (a <= b) (not a <= b) :=
        inspect a case
          0 :=
            left                 -- to prove: 0 <= b
          n.successor :=
            inspect b case
              0 :=
                right            -- to prove: not n.successor <= 0
              m.successor :=
                inspect n <= m case
                  left  := left
                    -- to prove: n <= m => n.successor <= m.successor

                  right := right
                    -- to prove: not n <= m => not n.successor <= m.successor
  \end{alba}
  %
  The elimination function of the outer pattern match expressed in Alba syntax
  \begin{alba}
    \ (a:Natural): Decision (a <= b) (not a <= b) :=
      inspect n case
        0 :=
          Decision (0 <= b) (not 0 <= b)
        n.successor :=
          Decision (n.successor <= b) (not n.successor <= b)
  \end{alba}
  %
  The elimination function of the inner pattern match expressed in Alba syntax
  \begin{alba}
    \ (b:Natural): Decision (n.successor <= b) (not n.successor <= b) :=
      inspect b case
        0 :=
          Decision (n.successor <= 0) (not n.succesor <= 0)

        m.successor :=
          Decision (n.successor <= m.successor)
                   (not n.successor <= m.successor)
  \end{alba}




\item[Decreasing Fixpoint Argument]
  %
  Each fixpoint needs a decreasing argument for recursive calls. It is the
  task of the term builder to find one decreasing argument which is decreased
  in each recursive call or flag an error if it cannot find a decreasing
  argument.



\item[Ambiguity]
  %
  Global function (or constant) names are not unique in Alba. We can have
  different functions with the same name. Only the name together with the
  signature has to be unique.

  Whenever the builder encounters a name which does not uniquely specify a
  global function, it has to build with the different functions in parallel
  until a function is rule out because of the typing rules.

\end{description}





\subsection{Requirements}

The input to the term builder:
%
\begin{enumerate}

\item A syntactic term from the source code

\item A context

\item An optional expected type
\end{enumerate}

Output of the term builder: Because of ambiguities the output is a list of the
following data
%
\begin{enumerate}

\item A term in the intermediate language whose type is the optional expected
  type.

\item An augmented context which contains in addition to the input context
  \begin{enumerate}
  \item Type variables which can be freely substituted with any type without
    disturbing the validity of the term. If there are free type variables the
    term is polymorphic. E.g. the term \code{nil A} has the free type variable
    \code{A:Any}. The user only writes \code{nil} but the term builder has to
    add the implicit argument. Since there is no way to determine it, it has
    to assume a type variable.
  \item Proof variables which are used in the term and which have to be
    substituted by the prover by concrete proofs.
  \end{enumerate}
\end{enumerate}


The required type of a syntactic term depends on where the term is positioned.
%
\begin{description}

\item[Top of the Repl]
  %
  The term does not have a required type. It can be anything: A type, an
  object, a sort, ...

\item[Type Annotation]
  %
  Examples:
  \begin{alba}
     reverse (A: Any) (l: List A): Specified (\r := r.is_reversal_of l)
       := ...

     \ (n:Natural): Natural := n + 1
  \end{alba}
   %
   In these examples all terms to the right of the colon \code{:} must be
   types. There is no requirement for the types except that they must be types
   i.e. their types must be sorts. Since we have no required type, we cannot
   introduce a variable to represent them.

 \item[Term with Type Annotation]
   %
   In the example
   \begin{alba}
     (3 + 4 / 8 * 3 : Natural) = list.length
   \end{alba}
   the term \code{3 + 4 / 8 * 3} has the type annotation
   \code{Natural}. Therefore the type annotation \code{Natural} is the
   required type for the term.

 \item[Function Definition]
   %
   If the term is the defining expression of a function definition and the
   result type of the function is specified, then the required type of the
   defining expression is the result type of the function.
   %
   \begin{alba}
     f (a:A) (b:B): R := exp
   \end{alba}

 \item[Argument]
   %
   An argument must be an argument of some function expression. The function
   expression has a type which clearly indicates the required types for the
   arguments. Therefore a syntactic expression in an argument position has a
   required type and we can introduce variables to represent the argument
   terms which we later substitute by the corresponding intermediate language
   terms.

 \item[Function]
   %
   In the syntactic term \code{f a b} the subterm \code{f} is in the function
   position. The required type of the whole expression is a required type for
   the return type of \code{f} i.e. the subexpression in the function
   position. Another requirement for the subterm \code{f} is that must be
   applicable to $n$ arguments.
\end{description}



\noindent In summary we have the requirements for a syntactic term
%
\begin{enumerate}

\item Required result type, which is either
  \begin{enumerate}

  \item nothing in the case of a toplevel expression in the repl

  \item some type, if the term is in a type annotation position (to the right
    of a colon)

  \item result type of a function definition or annotated type of an expression

  \item the type of a variable which has been introduced to represent the
    argument
  \end{enumerate}


\item Number of essential arguments (without implicit arguments and proof
  arguments). If the number of arguments is different from zero, then the term
  is in a function position.
\end{enumerate}







\newpage
\section{Type Inference (Old material)}

\subsection{Basics}

A global (constant or function) is uniquely found by its name and its
signature. Many globals can share the same name as long as their signature is
different.

Looking up the name results in a list of globals. If the list is empty, then a
global with that name does not exist.

Locals shadow all previously declared names. I.e. either one local or a list
of globals is returned by looking up a name.

In an expression a name is used with a certain number of essential arguments
(i.e. with an arity at its call site). This has to be compared with the actual
arity. The actual arity must be sufficient for the required arity at the call
site.

If the arity is sufficient, the formal arguments can be pushed into the
context and a type remains as the result type which must be unified with the
required result type (possibly instantiating substitutable type variables).


\paragraph{Look up a global} It is a function call with $n$ essential
arguments. The $n$ arguments and the corresponding type variables and proof
arguments can be extracted and pushed into the \emph{global} context with
dummy variables. If the global is not unique we get more than one context. The
context might have different inferable variables and different types for the
dummy variables.

\paragraph{Required types}
If it is explicitly given (result type of a function in a function definition
or explicitly typed expression), then it is only one type and not a set of
types.

If the expression is used as an argument of a function, then there can be
multiple required types. Anyhow, we have a context (or a set of contexts) and
for each context an explicit type or a pointer to an argument (whose type is
the required type).




\subsection{Unification}


A system of equations is in a \emph{solved form} iff it has the following
properties
%
\begin{enumerate}

\item All equations have the form $x = t$ where $x$ is a variable.

\item A variable that occurs on the left-hand side of an equation does not
  occur at the right-hand side of any equation.

\item A variable may occur only on one left-hand side.
\end{enumerate}

The system
$$
%
\begin{array}{lll}
  x &=& f\, y
  \\
  y &=& g\, x
\end{array}
$$
%
can be made inconsistent by substituting the second equation into the first
getting $x = f (g\, x)$ where $x$ occurs on the left and on the right-hand side.

The system
$$
\begin{array}{lll}
  x &=& f\, y
  \\
  y &=& g\, z
  \\
  z &=& c
\end{array}
$$
%
where $c$ does not contain any variables can be transformed into the solved
form
$$
\begin{array}{lll}
  x &=& f\, (g \, c)
  \\
  y &=& g\, c
  \\
  z &=& c
\end{array}
$$
%
because it has no circularity.

The non-circularity can be maintained easily on a system in solved
form. Assume we have
$$
%
\begin{array}{lll}
  x &=& t_x
  \\
  y &=& t_y
\end{array}
$$
%
in solved form (i.e. $t_x$ and $t_y$ contain neither $x$ nor $y$) and we want
to add a new equation $z = t_z$. We just use
$$
%
\begin{array}{lll}
  x &=& t_x[z := t_z]
  \\
  y &=& t_y[z := t_z]
  \\
  z &=& t_z[x,y := t_x, t_y]
\end{array}
$$
%
and check if any of the variables occurs on the right-hand side of its
equation. The system remains consistent if $t_z$ does not contain $x,y$ or if
$t_x,t_y$ do not contain $z$.


Question: Is it possible to avoid circularity without transforming the system
into the solved form on each step? Let's assume we have
$$
%
\begin{array}{lll}
  x &=& t_x
  \\
  y &=& t_y
\end{array}
$$
%
which is solvable i.e. $t_x$ does not contain $y$ or $t_y$ does not contain
$x$ and we want to add a new equation $z = t_z$. $z$ might be contained in
$t_x$ and/or $t_y$ and $x$ or $y$ might be contained in $t_z$.




\subsection{Type Safe Unification}

Since we have a well typed system it might be possible that circularity during
unification is impossible due to the typing rules.

Assume that $A$ is a type variable and during unification we get the equation
$A = L\, A$ where $L$ is any type constructor (e.g. \code{List}). Since we can
substitute equals for equals we would get the infinite chain
$$
  A = L\, A = L\, (L\, A) = L\, (L\, (L\, A)) \ldots
$$



Example: We want to build a term for the syntactic expression $a + b * c$ in
the context $\Gamma$. This is possible only if the variables $a, b, c, +, *$
occur in $\Gamma$ i.e. we assume a context
$$
\Gamma = [+:I\to I\to I, *:I\to I\to I, \ldots, a:I, b:I, c:I, \ldots]
$$


We don't know the type of the expression nor a term which
represents the expression. We add two unknows (i.e. variables) to the context.
%
$$
\Gamma, E: \Any, e: E
$$
%
Now we have to analyze $\cdot + \cdot$ as a binary operator i.e. a function
with two arguments. In the context we have $+ : I \to I \to I$ where $I$
represents the type of integer numbers.

We need a placeholder of type $I$ for each argument and get
$$
%
\Gamma,  E: \Any, e: E, u:I, v:I \vdash u + v: I
$$
%
We unify $e:E$ with $u+v:I$ and get the system
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
\end{array}
$$
%
Next we analyze the expression $a$ which is not a function call and therefore
does not need new placeholders.
$$
%
\Gamma,  E: \Any, e: E, u:I, v:I \vdash a:I
$$
%
Unification of $u:I$ and $a:I$ leads to
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
\end{array}
$$
%
Next we analyze $\cdot * \cdot$ and need again two new placeholders
$$
%
\Gamma,  E: \Any, e: E, u:I, v:I, w:I, x:I \vdash w * x: I
$$
%
and unify $v:I$ with $ w * x: I$ to get
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
  \\
  v &=& w * x
\end{array}
$$
%
Continuing the process we finally get
$$
%
\Gamma,  E: \Any, e: E, u:I, v:I, w:I, x:I
$$
%
with
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
  \\
  v &=& w * x
  \\
  w &=& b
  \\
  x &=& c
\end{array}
$$
%
This system can be resolved into
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& a + b * c
  \\
  u &=& a
  \\
  v &=& b * c
  \\
  w &=& b
  \\
  x &=& c
\end{array}
$$
%
where only the first two lines are interesting.





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main_alba_design"
%%% End:
