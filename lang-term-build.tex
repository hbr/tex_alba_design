\section{Term Building}


\subsection{Task}

The intermediate language of Alba is strictly typed. All bound variables need
explicit types, calls of polymorphic functions need type arguments and
propositions need proofs.

The language for the user is much more liberal, otherwise it would be very
tedious to write programs in Alba.

The task of term building is to fill the gaps between the user language and
the intermediate language.





\begin{description}

\item[Binders]
  %
  The user can write in program text
  \begin{alba}
    \ x y := e

    all x y: p
  \end{alba}
  and the term builder has to generate $\lambda x^A y^B. e$ and $\Pi
  x^A y^B  . p$ i.e. it has to infer the argument types.


\item[Implicit Type Arguments]
  %
  Polymorphic functions and constructors need type arguments in the
  intermediate language. In order to construct an empty list the constructor
  $\text{nil}$ receives the object type as an argument. The user does not
  provide this information. Therefore the source code terms
  \begin{alba}
    1 ^ 2 ^ []           -- [] is nil and (^) is cons

    reverse list
  \end{alba}
  %
  have to be transformed to
  $$
  \begin{array}{l}
    \text{cons}\, \Natural\, 1 \,(\text{cons}\, \Natural\, 2\, (\text{nil}\,
    \Natural))

    \\

    \text{reverse}\, \text{String} \, \text{list}
  \end{array}
  $$


\item[Implicit Proof Arguments]
  %
  The user does not supply explicit proof arguments. Let's assume we have the
  function definition
  \begin{alba}
    predecesssor (n:Natural): 0 < n -> Natural := ...
  \end{alba}
  %
  i.e. a function that can be called only with a nonnegative argument. Then
  the user can call the function with
  \begin{alba}
    predecessor n
  \end{alba}
  %
  The term builder does not generate the actual proof. This is the task of the
  prover. But the term builder generates an new variable for the missing proof
  (e.g. $p: 0 < n$) and generates the term $\text{predecesssor n p}$ in the
  intermediate language.

  Proof arguments are implicit only for functions whose result type is not a
  proposition. If the result type of a function is a proposition, then the
  proof arguments must be provided explicitly. If the user wants the prover to
  find the prove, then it is possible to write the wildcard \code{\_} instead
  of an explicit argument.


\item[Specified Type Splitting]
  %
  In Alba we have the specified type which is a simple type plus a
  specification which objects of that simple type must satisfy in order to be
  objects of the specified type. The specified type is defined as an inductive
  type
  %
  \begin{alba}
    class Specified (A:Any) (f:A -> Proposition): Any create
      specified (a:A): f a -> Specified f
  \end{alba}
  %
  We use the convention that an argument of a function never has a specified
  type. The simple type and the proposition must be separate arguments. But
  objects of specified type can be returned from functions (e.g. a number with
  a proof of the fact that it is a prime number).

  The term builder splits return values of specified type into simple values
  and proof values by using projections. The simple value is fed as an
  argument and the proof value is shifted into the context and can be used by
  the prover.

  The term builder uses the projection functions
  \begin{alba}
     value (A:Any) (f:A -> Proposition) (v:Specified f): A :=
       inspect v case
         specified a := a

     proof (A:Any) (f:A -> Proposition) (v:Specified f): f (value v) :=
       inspect v case
         specified _ p := p   -- result type of 'proof' is a proposition
                              -- therefore explicit proof arguments
  \end{alba}
  %
  Note that \code{A} and \code{f} are implicit type arguments for both
  functions. Therefore the user can call them by writing \code{value v} and
  \code{proof v}.


\item[Elimination Function]
  %
  The pattern match construct
  $\case(e, \lambda \ybold^\Abold x^T . R, \fbold)$ needs an elimination
  function $\lambda \ybold^\Abold x^T . R$ mapping the indices of the
  inductive type and an object of the inductive type into the result type of
  the pattern match expression (i.e. the term $R$ can depend on $\ybold$ and
  $x$).
  %
  \begin{alba}
     (<=) (a b:Natural): Decision (a <= b) (not a <= b) :=
        inspect a case
          0 :=
            left                 -- to prove: 0 <= b
          n.successor :=
            inspect b case
              0 :=
                right            -- to prove: not n.successor <= 0
              m.successor :=
                inspect n <= m case
                  left  := left
                    -- to prove: n <= m => n.successor <= m.successor

                  right := right
                    -- to prove: not n <= m => not n.successor <= m.successor
  \end{alba}
  %
  The elimination function of the outer pattern match expressed in Alba syntax
  \begin{alba}
    \ (a:Natural): Decision (a <= b) (not a <= b) :=
      inspect n case
        0 :=
          Decision (0 <= b) (not 0 <= b)
        n.successor :=
          Decision (n.successor <= b) (not n.successor <= b)
  \end{alba}
  %
  The elimination function of the inner pattern match expressed in Alba syntax
  \begin{alba}
    \ (b:Natural): Decision (n.successor <= b) (not n.successor <= b) :=
      inspect b case
        0 :=
          Decision (n.successor <= 0) (not n.succesor <= 0)

        m.successor :=
          Decision (n.successor <= m.successor)
                   (not n.successor <= m.successor)
  \end{alba}




\item[Decreasing Fixpoint Argument]
  %
  Each fixpoint needs a decreasing argument for recursive calls. It is the
  task of the term builder to find one decreasing argument which is decreased
  in each recursive call or flag an error if it cannot find a decreasing
  argument.



\item[Ambiguity]
  %
  Global function (or constant) names are not unique in Alba. We can have
  different functions with the same name. Only the name together with the
  signature has to be unique.

  Whenever the builder encounters a name which does not uniquely specify a
  global function, it has to build with the different functions in parallel
  until a function is rule out because of the typing rules.

\end{description}





\subsection{Requirements}

The input to the term builder:
%
\begin{enumerate}

\item A syntactic term from the source code

\item A context

\item An optional expected type
\end{enumerate}

Output of the term builder: Because of ambiguities the output is a list of the
following data
%
\begin{enumerate}

\item A term in the intermediate language whose type is the optional expected
  type.

\item An augmented context which contains in addition to the input context
  \begin{enumerate}
  \item Type variables which can be freely substituted with any type without
    disturbing the validity of the term. If there are free type variables the
    term is polymorphic. E.g. the term \code{nil A} has the free type variable
    \code{A:Any}. The user only writes \code{nil} but the term builder has to
    add the implicit argument. Since there is no way to determine it, it has
    to assume a type variable.
  \item Proof variables which are used in the term and which have to be
    substituted by the prover by concrete proofs.
  \end{enumerate}
\end{enumerate}


The required type of a syntactic term depends on where the term is positioned.
%
\begin{description}

\item[Top of the Repl]
  %
  The term does not have a required type. It can be anything: A type, an
  object, a sort, ...

\item[Type Annotation]
  %
  Examples:
  \begin{alba}
     reverse (A: Any) (l: List A): Specified (\r := r.is_reversal_of l)
       := ...

     \ (n:Natural): Natural := n + 1
  \end{alba}
   %
   In these examples all terms to the right of the colon \code{:} must be
   types. There is no requirement for the types except that they must be types
   i.e. their types must be sorts. Since we have no required type, we cannot
   introduce a variable to represent them.

 \item[Term with Type Annotation]
   %
   In the example
   \begin{alba}
     (3 + 4 / 8 * 3 : Natural) = list.length
   \end{alba}
   the term \code{3 + 4 / 8 * 3} has the type annotation
   \code{Natural}. Therefore the type annotation \code{Natural} is the
   required type for the term.

 \item[Function Definition]
   %
   If the term is the defining expression of a function definition and the
   result type of the function is specified, then the required type of the
   defining expression is the result type of the function.
   %
   \begin{alba}
     f (a:A) (b:B): R := exp
   \end{alba}

 \item[Argument]
   %
   An argument must be an argument of some function expression. The function
   expression has a type which clearly indicates the required types for the
   arguments. Therefore a syntactic expression in an argument position has a
   required type and we can introduce variables to represent the argument
   terms which we later substitute by the corresponding intermediate language
   terms.

 \item[Function]
   %
   In the syntactic term \code{f a b} the subterm \code{f} is in the function
   position. The required type of the whole expression is a required type for
   the return type of \code{f} i.e. the subexpression in the function
   position. Another requirement for the subterm \code{f} is that must be
   applicable to $n$ arguments.
\end{description}



\noindent In summary we have the requirements for a syntactic term
%
\begin{enumerate}

\item Required result type, which is either
  \begin{enumerate}

  \item nothing in the case of a toplevel expression in the repl

  \item some type, if the term is in a type annotation position (to the right
    of a colon)

  \item result type of a function definition or annotated type of an expression

  \item the type of a variable which has been introduced to represent the
    argument
  \end{enumerate}


\item Number of essential arguments (without implicit arguments and proof
  arguments). If the number of arguments is different from zero, then the term
  is in a function position.
\end{enumerate}





\subsection{Placeholders}

The term builder uses placeholders for terms/types which it does not yet know.

Placeholders are needed for
%
\begin{enumerate}

\item bound variables which do not have an explicit type (a variable of type
  \code{Any} will be introduced.


\item implicit arguments of functions (arguments which can be inferred from
  the rest of the signature)

\item actual function arguments which have not yet been analyzed

\end{enumerate}

The introduced variables are not arbitrary. They have to satisfy the
constraints
\begin{enumerate}
\item The actual type must be unifiable with the required type
\item A placeholder for an argument must be substitutable with the expression
  generated from the syntactic term of the actual argument.
\end{enumerate}

At the end of the term building some placeholders might not have
substitutions. This usually means that the expression is polymorphic (e.g. an
empty list whose element type is unknown).

During the algorithm we have a set of placeholders and a substitution
$$
\sigma = [y_0: t_0, y_1: t_1, \ldots]
$$
i.e. a list of placeholders/substitution term pairs with the invariant that a
substituted variable must not occur in any substitution term and that the
substituted variables $y_0, y_1, \ldots$ are a subset of the placeholders.




\subsection{Algorithm Data}


\noindent Input:

\begin{enumerate}

\item Nonempty list of

  \begin{enumerate}

  \item Context

  \item Set of all placeholders / Substitution

  \item Stack of placeholders representing not yet analyzed function arguments

  \item Number of arguments (to which the syntactic expression is applied) and
    the application mode (normal, target of object call, operand)

  \item Optional expected type
  \end{enumerate}

\item Syntactic expression
\end{enumerate}

Lists are needed because of ambiguity. A elements of the list have the same
number of arguments. If there is an expected type, there is one for all
elements. If the expected type is an arbitrary type, it is the same for all
list elements.

If no error occurs, then the algorithm outputs a nonempty list of:

\begin{enumerate}

\item Context

\item Set of all placeholders / Substitution

\item Stack of placeholders representing not yet analyzed function arguments

\item Term and its type in the intermediate language

\end{enumerate}

The context, set of placeholders, substitution and the stack of placeholders
are common elements of the input and output structure.




\subsection{Implicit vs Explicit Arguments}

All arguments in the syntactic terms are explicit. Implicit arguments are
never written in the source code.

A term in function position must have a type which in key normal form looks
like

$$
\Pi \xbold^\Abold . R = \Pi x_0^{A_0} x_1^{A_1} \ldots .\, R
$$

If $A_i:\Prop$, then $A_i$ is a proposition and the $i$-th argument is a
proof. If $R:\Prop$, then $\Pi \xbold^\Abold. R$ is a proposition and a term
of this type is a proof.

In propositional function types all proof arguments are explicit. In
nonpropositional function types the proof arguments are implicit.

An argument described by the pair $x_i: A_i$ is implicit if $x_i$ occurs
either in some of the following nonpropositional $A_j$ for $i < j$ or in the
nonpropositional result type.





\subsection{Apply Terms to Placeholders}

Every syntactic subterm might be applied to some arguments, either explicit or
implicit, if it is in a function position.

The term in the function position is analyzed before the terms of the actual
arguments. Therefore placeholders are introduced for the explicit and implicit
arguments (it is possible that there are no explicit arguments, but implicit
arguments).

The optional expected type of a syntactic term is not the type of the
syntactic term, but the type of the syntactic term applied to its arguments.





\subsection{Terminal Elements}

The possible terminal elements (syntactic terms which have no subterms) of a
syntactic term are
%
\begin{enumerate}

\item Identifier / Operator

\item Number

\item Character

\item String

\item Sort (\code{Proposition} and \code{Any})
\end{enumerate}

Numbers, characters, strings and sorts cannot be applied to
arguments. Identifiers, operators and numbers can have ambiguous types.

The expected type is the type of the expression applied to the arguments.

For each possible terminal element we get a list of term/type pairs (which can
be a singleton list). Transforming the type into key normal form must result
in $\Pi x^A y^B \ldots . R$ with sufficient arguments.

We generate placeholders for all arguments (implicit and explicit, until
sufficient) and shift them with their corresponding types into the
context. The essential ones are shifted onto the stack of not yet analyzed
arguments.

Then we unify $R$ with the expected type of the expression with arguments.

We return the term applied to the placeholder arguments (implicit and
explicit) in the output structure. I.e. the type of the returned term has the
expected type (if there is one).




\subsection{Function Application}

A function application has the forms

\begin{alba}
  f a b c ...        -- normal mode

  a.f b c ...        -- oo style mode

  a binop b          -- operator expression
\end{alba}



\vskip 5mm
TBD
\vskip 5mm



\subsection{Function Term / Abstraction}

A function term has the possible forms

\begin{alba}
  \ x y ... := exp                     -- without types

  \ (x:A) (y:B) ... : R := exp         -- fully typed

  (a +)                                -- section '\x := a + x'

  (+ a)                                -- section '\x := x + a'
\end{alba}


For unknown argument type we have to introduce type variables into the context.

For
\begin{alba}
  \ x y (z:C) := exp
\end{alba}
%
we need the context
$$
    \Gamma, A:\Any, B:\Any, x:A, y:B, z:C \ldots
$$
%
where the two placeholder type variable $A$ and $B$ have been introduced to
describe the types of the variables $x$ and $y$.

The type $C$ might contain the variables $x$ and $y$ (e.g. \code{C = x < y}
i.e. the analysis of $C$ might already determine the type variables $A$ and
$B$.

Finally we analyze the expression \code{exp} in the new context and get an
itermediate language term $e:E$ in the context.

At the end some unassigned type variables can remain. We shift them all to the
left of $x:A$ and form $\lambda x^A y^B z^C . e : \Pi x^A y^B z^C . E$ in the
context below $x$.

During the analysis of \code{exp} it is possible that some proof variables
like $x_p:p$ have been introduced. The actual proof has not yet been
generated, but it might depend on $x,y,z$. In order to eliminate $x_p$ we
introduce a new proof variable $y_p:\Pi x^A y^B z^C . p$ to the left of $x:A$
and substitute $x_p$ by $y_p x y z$.








\subsection{Function Type}


\begin{alba}
  all x y ... : exp

  all (x:A) (y:B) ... : exp

  all (x:A) : B -> ... -> Z        -- all (x:A) (_:B) ... : Z
\end{alba}

\vskip 5mm
TBD
\vskip 5mm





\subsection{Pattern Match}

\vskip 5mm
TBD
\vskip 5mm







\newpage
\section{Type Inference (Old material)}

\subsection{Basics}

A global (constant or function) is uniquely found by its name and its
signature. Many globals can share the same name as long as their signature is
different.

Looking up the name results in a list of globals. If the list is empty, then a
global with that name does not exist.

Locals shadow all previously declared names. I.e. either one local or a list
of globals is returned by looking up a name.

In an expression a name is used with a certain number of essential arguments
(i.e. with an arity at its call site). This has to be compared with the actual
arity. The actual arity must be sufficient for the required arity at the call
site.

If the arity is sufficient, the formal arguments can be pushed into the
context and a type remains as the result type which must be unified with the
required result type (possibly instantiating substitutable type variables).


\paragraph{Look up a global} It is a function call with $n$ essential
arguments. The $n$ arguments and the corresponding type variables and proof
arguments can be extracted and pushed into the \emph{global} context with
dummy variables. If the global is not unique we get more than one context. The
context might have different inferable variables and different types for the
dummy variables.

\paragraph{Required types}
If it is explicitly given (result type of a function in a function definition
or explicitly typed expression), then it is only one type and not a set of
types.

If the expression is used as an argument of a function, then there can be
multiple required types. Anyhow, we have a context (or a set of contexts) and
for each context an explicit type or a pointer to an argument (whose type is
the required type).




\subsection{Unification}


A system of equations is in a \emph{solved form} iff it has the following
properties
%
\begin{enumerate}

\item All equations have the form $x = t$ where $x$ is a variable.

\item A variable that occurs on the left-hand side of an equation does not
  occur at the right-hand side of any equation.

\item A variable may occur only on one left-hand side.
\end{enumerate}

The system
$$
%
\begin{array}{lll}
  x &=& f\, y
  \\
  y &=& g\, x
\end{array}
$$
%
can be made inconsistent by substituting the second equation into the first
getting $x = f (g\, x)$ where $x$ occurs on the left and on the right-hand side.

The system
$$
\begin{array}{lll}
  x &=& f\, y
  \\
  y &=& g\, z
  \\
  z &=& c
\end{array}
$$
%
where $c$ does not contain any variables can be transformed into the solved
form
$$
\begin{array}{lll}
  x &=& f\, (g \, c)
  \\
  y &=& g\, c
  \\
  z &=& c
\end{array}
$$
%
because it has no circularity.

The non-circularity can be maintained easily on a system in solved
form. Assume we have
$$
%
\begin{array}{lll}
  x &=& t_x
  \\
  y &=& t_y
\end{array}
$$
%
in solved form (i.e. $t_x$ and $t_y$ contain neither $x$ nor $y$) and we want
to add a new equation $z = t_z$. We just use
$$
%
\begin{array}{lll}
  x &=& t_x[z := t_z]
  \\
  y &=& t_y[z := t_z]
  \\
  z &=& t_z[x,y := t_x, t_y]
\end{array}
$$
%
and check if any of the variables occurs on the right-hand side of its
equation. The system remains consistent if $t_z$ does not contain $x,y$ or if
$t_x,t_y$ do not contain $z$.


Question: Is it possible to avoid circularity without transforming the system
into the solved form on each step? Let's assume we have
$$
%
\begin{array}{lll}
  x &=& t_x
  \\
  y &=& t_y
\end{array}
$$
%
which is solvable i.e. $t_x$ does not contain $y$ or $t_y$ does not contain
$x$ and we want to add a new equation $z = t_z$. $z$ might be contained in
$t_x$ and/or $t_y$ and $x$ or $y$ might be contained in $t_z$.




\subsection{Type Safe Unification}

Since we have a well typed system it might be possible that circularity during
unification is impossible due to the typing rules.

Assume that $A$ is a type variable and during unification we get the equation
$A = L\, A$ where $L$ is any type constructor (e.g. \code{List}). Since we can
substitute equals for equals we would get the infinite chain
$$
  A = L\, A = L\, (L\, A) = L\, (L\, (L\, A)) \ldots
$$



Example: We want to build a term for the syntactic expression $a + b * c$ in
the context $\Gamma$. This is possible only if the variables $a, b, c, +, *$
occur in $\Gamma$ i.e. we assume a context
$$
\Gamma = [+:I\to I\to I, *:I\to I\to I, \ldots, a:I, b:I, c:I, \ldots]
$$


We don't know the type of the expression nor a term which
represents the expression. We add two unknows (i.e. variables) to the context.
%
$$
\Gamma, E: \Any, e: E
$$
%
Now we have to analyze $\cdot + \cdot$ as a binary operator i.e. a function
with two arguments. In the context we have $+ : I \to I \to I$ where $I$
represents the type of integer numbers.

We need a placeholder of type $I$ for each argument and get
$$
%
\Gamma,  E: \Any, e: E, u:I, v:I \vdash u + v: I
$$
%
We unify $e:E$ with $u+v:I$ and get the system
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
\end{array}
$$
%
Next we analyze the expression $a$ which is not a function call and therefore
does not need new placeholders.
$$
%
\Gamma,  E: \Any, e: E, u:I, v:I \vdash a:I
$$
%
Unification of $u:I$ and $a:I$ leads to
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
\end{array}
$$
%
Next we analyze $\cdot * \cdot$ and need again two new placeholders
$$
%
\Gamma,  E: \Any, e: E, u:I, v:I, w:I, x:I \vdash w * x: I
$$
%
and unify $v:I$ with $ w * x: I$ to get
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
  \\
  v &=& w * x
\end{array}
$$
%
Continuing the process we finally get
$$
%
\Gamma,  E: \Any, e: E, u:I, v:I, w:I, x:I
$$
%
with
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
  \\
  v &=& w * x
  \\
  w &=& b
  \\
  x &=& c
\end{array}
$$
%
This system can be resolved into
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& a + b * c
  \\
  u &=& a
  \\
  v &=& b * c
  \\
  w &=& b
  \\
  x &=& c
\end{array}
$$
%
where only the first two lines are interesting.





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main_alba_design"
%%% End:
