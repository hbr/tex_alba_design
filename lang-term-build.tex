\section{Term Building}


\subsection{Task}

The intermediate language of Alba is strictly typed. All bound variables need
explicit types, calls of polymorphic functions need type arguments and
propositions need proofs.

The language for the user is much more liberal, otherwise it would be very
tedious to write programs in Alba.

The task of term building is to fill the gaps between the user language and
the intermediate language.





\begin{description}

\item[Binders]
  %
  The user can write in program text
  \begin{alba}
    \ x y := e

    all x y: p
  \end{alba}
  and the term builder has to generate $\lambda x^A y^B. e$ and $\Pi
  x^A y^B  . p$ i.e. it has to infer the argument types.


\item[Implicit Type Arguments]
  %
  Polymorphic functions and constructors need type arguments in the
  intermediate language. In order to construct an empty list the constructor
  $\text{nil}$ receives the object type as an argument. The user does not
  provide this information. Therefore the source code terms
  \begin{alba}
    1 ^ 2 ^ []           -- [] is nil and (^) is cons

    reverse list
  \end{alba}
  %
  have to be transformed to
  $$
  \begin{array}{l}
    \text{cons}\, \Natural\, 1 \,(\text{cons}\, \Natural\, 2\, (\text{nil}\,
    \Natural))

    \\

    \text{reverse}\, \text{String} \, \text{list}
  \end{array}
  $$


\item[Implicit Proof Arguments]
  %
  The user does not supply explicit proof arguments. Let's assume we have the
  function definition
  \begin{alba}
    predecesssor (n:Natural): 0 < n -> Natural := ...
  \end{alba}
  %
  i.e. a function that can be called only with a nonnegative argument. Then
  the user can call the function with
  \begin{alba}
    predecessor n
  \end{alba}
  %
  The term builder does not generate the actual proof. This is the task of the
  prover. But the term builder generates an new variable for the missing proof
  (e.g. $p: 0 < n$) and generates the term $\text{predecesssor n p}$ in the
  intermediate language.


\item[Specified Type Splitting]
  %
  In Alba we have the specified type which is a simple type plus a
  specification which objects of that simple type must satisfy in order to be
  objects of the specified type. The specified type is defined as an inductive
  type
  %
  \begin{alba}
    class Specified A (f: Predicate A): Any create
      specified (value: A) (proof: f value): Specified f
  \end{alba}
  %
  We use the convention that an argument of a function never has a specified
  type. The simple type and the proposition must be separate arguments. But
  objects of specified type can be returned from functions (e.g. a number with
  a proof of the fact that it is a prime number).

  The term builder splits return values of specified type into simple values
  and proof values by using projections. The simple value is fed as an
  argument and the proof value is shifted into the context and can be used by
  the prover.

  The term builder uses the projection functions
  \begin{alba}
     value A (f: Predicate A) (v: Specified f): A :=
       inspect v case
         specified a := a

     proof A (f: Predicate A) (v: Specified f): f (value v) :=
       inspect v case
         specified _ := _     -- The proof argument is implicit
  \end{alba}
  %
  Note that \code{A} and \code{f} are implicit type arguments for both
  functions. Therefore the user can call them by writing \code{value v} and
  \code{proof v}.

  It might be interesting to use a fold like function
  \begin{alba}
     fold (A:Any) (f:A->Proposition) (v:Specified f)
          (B:Any) (g: all x: f x -> B): B :=
       inspect v case
         specified x := g x
  \end{alba}
  where \code{g} is a function using the specified value and a proof of its
  property.

\item[Elimination Function]
  %
  The pattern match construct
  $\case(e, \lambda \ybold^\Abold x^T . R, \fbold)$ needs an elimination
  function $\lambda \ybold^\Abold x^T . R$ mapping the indices of the
  inductive type and an object of the inductive type into the result type of
  the pattern match expression (i.e. the term $R$ can depend on $\ybold$ and
  $x$).
  %
  \begin{alba}
     (<=) (a b:Natural): Decision (a <= b) (not a <= b) :=
        inspect a case
          0 :=
            left                 -- to prove: 0 <= b
          n.successor :=
            inspect b case
              0 :=
                right            -- to prove: not n.successor <= 0
              m.successor :=
                inspect n <= m case
                  left  := left
                    -- to prove: n <= m => n.successor <= m.successor

                  right := right
                    -- to prove: not n <= m => not n.successor <= m.successor
  \end{alba}
  %
  The elimination function of the outer pattern match expressed in Alba syntax
  \begin{alba}
    \ (a:Natural): Decision (a <= b) (not a <= b) :=
      inspect n case
        0 :=
          Decision (0 <= b) (not 0 <= b)
        n.successor :=
          Decision (n.successor <= b) (not n.successor <= b)
  \end{alba}
  %
  The elimination function of the inner pattern match expressed in Alba syntax
  \begin{alba}
    \ (b:Natural): Decision (n.successor <= b) (not n.successor <= b) :=
      inspect b case
        0 :=
          Decision (n.successor <= 0) (not n.succesor <= 0)

        m.successor :=
          Decision (n.successor <= m.successor)
                   (not n.successor <= m.successor)
  \end{alba}




\item[Decreasing Fixpoint Argument]
  %
  Each fixpoint needs a decreasing argument for recursive calls. It is the
  task of the term builder to find one decreasing argument which is decreased
  in each recursive call or flag an error if it cannot find a decreasing
  argument.



\item[Ambiguity]
  %
  Global function (or constant) names are not unique in Alba. We can have
  different functions with the same name. Only the name together with the
  signature has to be unique.

  Whenever the builder encounters a name which does not uniquely specify a
  global function, it has to build with the different functions in parallel
  until a function is rule out because of the typing rules.

\end{description}




\subsection{Implicit Arguments}

The syntactic terms do not contain implicit arguments. Implicit arguments are
generated by the compiler.

A term in a function position must have a type which in key normal form looks
like

$$
\Pi \xbold^\Abold . R = \Pi x_0^{A_0} x_1^{A_1} \ldots .\, R
$$

An argument $x_i$ is implicit in the following two cases:

\begin{enumerate}
\item $x_i$ is a proof argument i.e. $A_i : \Prop$ is a valid typing
  judgement.

\item $x_i$ is an inferable type constructor variable i.e. $A_i$ reduces to a
  kind and $x_i$ occurs as a strict subterm in some other $A_j$ which is not a
  proposition (i.e. $A_j:\Any_k$ for some $k$ and $\Any_k$ is the principal
  type of $A_j$) or $x_i$ occurs in the result type $R$.
\end{enumerate}

Note that both cases are mutually exclusive because ``$A_i$ is a proposition''
and ``$A_i$ reduces to a kind'' are mutually exclusive. The type of a kind is
always $\Any_k$ and never $\Prop$.

It is important to see that the types of implicit type variables (or type
constructor variables) are always inferable by unification. Proof: Let's look
at the last implicit type variable $x_m$. By definition it must occur as a
strict subterm either in some type of an explicit variable or in the result
type. By unification we can always assign a type to a variable occuring as a
strict subterm inside of some known types. Having the type of the last
implicit argument, we can infer the type of the previous implicit
argument. Continuing we can infer the types of all implicit non proof
arguments.


Because of the possibility of implicit arguments, a naive unification of
required and actual types does not work. Unification must be coupled
intelligently with term building.

An example illustrates the complexity.

\begin{alba}
  -- constructors for lists
  []:  all A: List A
  (^): all A: A -> List A -> List A

  -- left folding
  fold_left A (a: List A) (B: Any) (f: A -> B -> B) (s: B): B :=
    inspect a case
      [] :=
        s
      h ^ t :=
        fold_left t f (f h s)

   -- list reversal
   reverse A (a: List A): List A :=
     fold_left a (^) []
\end{alba}

Analyzing the term building of the last line we get the following situation:

\begin{itemize}
\item substitution
  \begin{alba}
    B := List A
  \end{alba}
\item required type for $(\caret)$:
  \begin{alba}
    A -> B -> B
  \end{alba}
\item actual type for $(\caret)$:
  \begin{alba}
    all X: X -> List X -> List X
  \end{alba}
\end{itemize}
The required type is a function type with two arguments, the actual type is a
function type with three arguments where the first argument is the polymorphic
argument. Unification is possible only if the first argument of the actual
signature is considered as implicit.


For the constructor $[]$ we have a similar situation. The required type is a
constant (0-ary function type) and the actual type is a function type with one
argument.


Assume that the required signature starts with $n$ implicit arguments and the
actual signature starts with $k$ implicit arguments, then
$$
n \le k
$$
must be satisfied i.e. the required signature must not have more implicit
arguments than the actual signature.

$k - n$ implicit arguments are applied before the unification is done.

Note that if an expression is used in an argument position there is always a
non-dummy required signature.





\subsection{Placeholders}

The term builder uses placeholders for terms/types which it does not yet know.

Placeholders are needed for
%
\begin{enumerate}

\item types of bound variables which do not have an explicit type (a variable
  of type $\Any_1$ will be introduced)

  Restriction: An untyped bound variable has to appear in an argument position
  before it can occur in a function position.

\item inferable implicit arguments (placeholder represents a type or a type
  constructor)

\item proof arguments

\item subterms which have not yet been analyzed

\item expected types if there is no explicit expected type (a variable of type
  $\Any_2$ will be introduced)

\end{enumerate}



During the algorithm we have a set of placeholders and a substitution
$$
\sigma = [x_{i_0}: a_0,\, x_{i_1}: a_1,\, \ldots]
$$
i.e. a list of placeholders/substitution term pairs with the invariant that a
substituted variable must not occur in any substitution term and that the
substituted variables $x_{i_0}, x_{i_1}, \ldots$ are a subset of the
placeholders.





\subsection{Algorithm}

When analyzing a syntatic expression $\text{exp}$ which is applied to $n$
arguments we do this in a context which has a placeholder $e$ representing the
expression applied to its arguments and potentially many more variables which
are either placeholders or bound variables.

$$
\Gamma, \ldots, e^E, \ldots
$$

$E$ is the required result type of the expression applied to its arguments. It
might be a placeholder without substitution if we do not know the expected
result type.

\begin{itemize}

\item Input:
  \begin{itemize}
  \item Context with placeholders an substitutions
  \item Pointer to the placeholder representing the expression applied to its
    arguments.
  \item Number of (explicit) arguments to which the expression is applied
  \end{itemize}

\item Output:
  \begin{itemize}
  \item Context with the placeholder $e$ substituted by a term for the
    expression $\text{exp}$ applied to its arguments and at least $n$ more
    placeholders representing the arguments.
  \item An array of  $n$ pointers to the placeholders for the arguments.
  \end{itemize}
\end{itemize}

Initially analyzing the syntactic expression $\text{exp}$ applied to no
arguments in the context $\Gamma$ we start with the following context and
substitutions
$$
%
\begin{array}{l}
  \Gamma, E^{\Any_2}, e^E
  \\
  \sigma =
  \begin{cases}
    [E : R] & R \text{ is the required type}
    \\
    []      & \text{there is no required type}
  \end{cases}
\end{array}
$$
%
We use $\Any_2$ as the type of $E$ in order to be able to substitute $e$ by
$\Any_0$ and correspondingly $E$ by $\Any_1$.

We expect the algorithm to terminate with a context and substitutions where
the placeholder $e$ has got a substitution.


Now we have to specify the algorithm for the different cases of syntactic
expressions.


\subsubsection{Literals}

There literals for
\begin{itemize}
\item numbers
\item strings
\item characters
\end{itemize}

None of them can accept arguments.

For each of them there is a term which we have to unify with the placeholder.

In case of success we are ready and return an empty array (no arguments).



\subsubsection{Sorts}

In user terms we have only the sorts
\begin{itemize}
\item \code{Any}
\item \code{Proposition}
\end{itemize}

No sort can accept arguments.

I.e. we unify $\Any_0$ or $\Prop$ with the placeholder and return the context
with an empty array.




\subsubsection{Names or Operators}

Names and operators are stored in a string map which return a (possibly empty)
list of variables. Each of the variables has a type.

The type of the variable must not be a placeholder without substitution, if
there are explicit arguments i.e. $n > 0$.

The type of the variable has to be capable to accept $n$ explicit arguments
i.e. it has to have the key normal form $\Pi x^A y^B \ldots . R$ where $x, y,
\ldots$ represent the $n$ explicit arguments plus all implicit arguments which
occur before  the explicit arguments.

Two cases are possible
\begin{enumerate}

\item The expected type $E$ is a type variable without substitution:

  \begin{enumerate}
  \item Substitute $E$ with $R$.

  \item Introduce the placeholders $x, y, \ldots$.

  \item Substitute $e$ by $v x y \ldots$ where $v$ is the variable.

  \item Return the new context with an array pointing to the placeholders of
    the explicits arguments in $x, y, \ldots$.
  \end{enumerate}

\item The expected type $E$ has a signature:

  In that case we have to compare the signatures of $E$ and $R$.

  \begin{enumerate}
  \item $R$ and $E$ start with the same number of implicit arguments:

    \begin{enumerate}
    \item  Unify the signatures of $R$ and $E$.

    \item Introduce the placeholders $x, y, \ldots$.

    \item Substitute $e$ by $v x y \ldots$ where $v$ is the variable.

    \item Return the new context with an array pointing to the placeholders of
      the explicits arguments in $x, y, \ldots$.
    \end{enumerate}


  \item $R$ starts with more implicit arguments than $E$: I.e. $R = \Pi u^U v^V
    \ldots . R'$ where $u, v, \ldots$ are the implicit arguments in $R$ which
    are more than the implicit arguments of $E$.

    \begin{enumerate}
    \item  Unify $R'$ and $E$. Introduce placeholders $x, y, \ldots, u, v, \ldots$.

    \item Substitute $E$ by $v x y \ldots u v \ldots$.

    \item Return the new context with an array pointing to the placeholders of
      the explicits arguments in $x, y, \ldots$.
    \end{enumerate}


  \item $R$ starts with fewer implicit arguments than $E$:

    This is an error condition.

  \end{enumerate}

\end{enumerate}



\subsubsection{Function Application}


\begin{alba}
  f a b c ...             -- normal function application
  a.f b c ...             -- oo style function application
  a + b                   -- operator expression
\end{alba}


\begin{enumerate}

\item Analyze the syntactic expression $f$ which is applied to $n$ arguments
  with a pointer to the placeholder of the whole expression and receive an
  array of $n$ pointers to the placeholders for the arguments.

\item Analyze each syntactic expression for the arguments which are applied to
  $0$ arguments with a pointer to the corresponding placeholder.

\end{enumerate}

There is nothing more to be done, because the first step already generated a
substitution for the placeholder of the whole expression and the subsequence
steps generate substitutions for the placeholders of the arguments.




\vskip 5mm
\subsubsection{Lambda Abstraction}

\begin{alba}
  \ (x: A) (y: B) ... : R := exp      -- fully typed
  \ x y ... := exp                    -- untyped
  (a+)                                -- means \ x := a + x
  (+a)                                -- means \ x := x + a
\end{alba}


\begin{enumerate}
\item Process signature:

  For each formal argument push a placeholder for the type and the bound
  variable onto the context to get
  $$
  \Gamma, \ldots, e^E, \ldots, A^{\Any_2}, x^A
  $$

  If there is an explicit type, analyze the syntactic expression for the type
  with a pointer to $A$.

  After pushing all arguments push a placeholer for the result type and a
  placeholder for the inner expression onto the context to get

  $$
  \Gamma, \ldots, e^E, \ldots, A^{\Any_2}, x^A, \ldots, R^{\Any_2}, f^R
  $$

  If there is an explicit result type, analyze the syntactic expression for the
  result type with a pointer to $R$.


\item Find prefix of the formal arguments which correspond to the $n$
  arguments to which the lambda abstraction is applied.

  Scan the formal arguments left to right skipping all implicit arguments
  until $n$ explicit arguments are found. Assume that $u$ is the first
  argument which does not correspond to an explicit argument.

  $$
  \Gamma, \ldots, e^E, \ldots, A^{\Any_2}, x^A, \ldots, u^U, \ldots, R^{\Any_2}, f^R
  $$

\item Exploit the information of the expected result type $E$, if possible.

  \begin{enumerate}
  \item The expected result type $E$ is an unsubstituted placeholder

    TBD

  \item The expected result type $E$ is not an unsubstituted placeholder

    Analyze the signature of $E$.

    In the remaining formal arguments of the lambda abstraction (i.e. starting
    from $u$ skip all implicit arguments until there are not more implicit
    arguments than in the signature of $E$.

    Unify the remaining formal arguments of the lambda abstraction with the
    signature of $E$.
  \end{enumerate}


\item Analze $\text{exp}$ with a pointer to $f$.

\item Substitute placeholders

  During the analysis all placeholders for the types of the bound variables
  must have received substitutions which do not contain placeholders to the
  right of $A$ (the placeholder for the type of the first formal argument).

  If this is not the case, the type of the corresponding bound variable cannot
  be inferred completely which is an error condition.

  There might remain some other placeholders to the left of $A$ which do not
  have substitutions. However these placeholders do not occur in the
  substitutions of the placeholders for the types of the formal arguments.

  We eliminate all placeholders having substitutions (except $f$ and $R$) by
  replacing them by their substitutions and move all placeholders without
  substitutions to the left of the bound variables resulting in
  $$
  \Gamma, \ldots, e^E, \ldots, x^{A'}, y^{B'} \ldots, R^{\Any_2}, f^R
  $$

\item Generate the lambda abstraction applied to the arguments

  If $E$ is a placeholder without substitution we add the substitution $\Pi
  x^{A'} y^{B'} \ldots . R$ (replacing $R$ by its substitution).

  Generate placeholders $x, y, \ldots$ for the formal arguments including all
  formal arguments corresponding to explicit actual arguments and the skipped
  implicit arguments.

  Substitute $e$ by ($\lambda x^{A'} y^{B'} \ldots . f) x y \ldots$ (using the
  substitution of $f$).

  Return pointers to the part of $x, y \ldots$ which correspond to the
  explicit actual arguments.

\end{enumerate}





\vskip 5mm
\subsubsection{Function Type}


\begin{alba}
  all (x: A) (y: B): R                -- fully typed
  all x y: R                          -- untyped
\end{alba}
TBD

\vskip 5mm
\subsubsection{Fixpoint}

\begin{alba}
  f (x: A) (y: B) ... : R := exp
  f x y ... := exp
\end{alba}

TBD

\vskip 5mm
\subsubsection{Pattern Match}

TBD











\subsection{Example}




\subsubsection{Example with Polymorphism}


We want to analyze the syntactic term

\begin{alba}
  all a: reverse (reverse a) = a
\end{alba}

in the context
$$
\Gamma = [e^{\Pi A^\Any. A \to A \to \Prop}, L^{\Any\to\Any}, r^{\Pi A^\Any. L A \to L A}]
$$
where $e$ is an abbreviation for $=$ and $r$ is an abbreviation for
\code{reverse}

For all unkown types and not yet analyzed arguments we introduce substitutable
variables and let unification instantiated them. Step by step we get the
following new contexts and partially analyzed terms.
$$
\begin{array}{lll}
  \Gamma, A^\Any, a^A, B^\Any, u^B, v^B
  & \vdash
  & e B u v : \Prop

  \\

  \Gamma, A^\Any, a^A, B^\Any, u^B, v^B, C^\Any, w^{L C}
  & \vdash
  & e B (r C w) v : \Prop

  \\

  \Gamma, A^\Any, a^A, B^\Any, u^B, v^B, C^\Any, w^{L C}, D^\Any, x^{L D}
  & \vdash
  & e B (r C (r D x)) v : \Prop

  \\

  \Gamma, A^\Any, a^A, B^\Any, u^B, v^B, C^\Any, w^{L C}, D^\Any, x^{L D}
  & \vdash
  & e B (r C (r D a)) v : \Prop

  \\

  \Gamma, A^\Any, a^A, B^\Any, u^B, v^B, C^\Any, w^{L C}, D^\Any, x^{L D}
  & \vdash
  & e B (r C (r D a)) a : \Prop
\end{array}
$$
%
We don't have a type for $a$, therefore we introduce the type variable
$A$. Then we can introduce the variable $a$ of type $A$. The variable $a$ is
not substitutable.

Equality $e$ needs a type and two elements to compare. For the type we
introduce $B$ and for the elements to compare we introduce $u$ and $v$.

List reversal $r$ needs an element type and a list to reverse. For the
element type we introduce $C$ and for the list to reverse we introduce
$w$. The outer reversal returns the type $L C$ which we unify with $B$


For the inner reversal we introduce $D$ and $x$. The result type of the inner
reversal is $L D$ which we unify with $L C$ which is the argument type of the
outer reversal.

Finally we associate $x$ and $v$ with $a$ which requires the unification of
$A$ with $L D$ and $A$ with $B$.



The following substitutions are produced by analysis of arguments and
unification.
$$
\begin{array}{llll}
  u & := & r C w  &\quad  B = L C
  \\
  B & := & L C
  \\
  w & := & r D x  &\quad  L C = L D
  \\
  C & := & D
  \\
  x & := & a      &\quad  A = L D
  \\
  A & := & L D
  \\
  v & := & a      &\quad  A = B
\end{array}
$$
%

Substitutable variables in the order of introduction and their substitutions
and final substitutions.
$$
\begin{array}{llll}
  A^\Any &:=& L D
  \\
  B^\Any &:=& L C    &\quad L D
  \\
  u^B   &:=& r C w  &\quad  r D (r D a)
  \\
  v^B    &:=& a
  \\
  C^\Any &:=& D
  \\
  w^C    &:=& r D x &\quad  r D a
  \\
  D^\Any
  \\
  x^{L D} &:=& a
\end{array}
$$

$D$ is the only substitutable variable which remains unsubstituted. Shifting
$D$ down and doing all substitutions we get
$$
\Gamma, D^\Any, a^{L D} \vdash e (L D) (r D (r D a)) a : \Prop
$$
%
and finally
$$
\Gamma \vdash \Pi D^\Any a^{L D} .\, e (L D) (r D (r D a)) a : \Prop
$$
%


We can generate a function expression
$$
\Gamma \vdash \lambda A a B u v C w D x. e B u v
: \Pi A^\Any a^A u^B v^B C^\Any w^{L C} D^\Any x^{L D}
$$


Introduce two new variables $D$ and $a$ and evaluate the function expression
$$
\Gamma, D^\Any, a^{L D} \vdash (\lambda A a B u v C w D x. e B u v) (L D) a (L
D) (r D (r D a)) a (r D a) : \Prop
$$
which as above results in
$$
\Gamma, D^\Any, a^{L D} \vdash e (L D) (r D (r D a)) a : \Prop
$$
and finally in
$$
\Gamma \vdash \Pi D^\Any a^{L D} .\, e (L D) (r D (r D a)) a : \Prop
$$


\subsubsection{Restrictions to Reduce Complexity}

We do not allow
\begin{alba}
  double_reversal: all a: reverse (reverse a) = a
\end{alba}

because the polymorphic type argument of \code{reverse} cannot be inferred.
All arguments must be explicit. Only the following expression is valid

\begin{alba}
  all (A: Any) (a: List A): reverse (reverse a) = a
  -- or shorter
  all A (a: List A): reverse (reverse a) = a
\end{alba}


Other example:

\begin{alba}
  all n a: sum (n ^ a) = n + sum a
\end{alba}
in the context
$$
\Gamma = [
e^{\Pi A^\Any. A\to A\to\Prop},
\Natural^\Any,
p^{\Natural\to\Natural\to\Natural},
L^{\Any\to\Any},
c^{\Pi A^\Any. A \to L A \to L A},
s^{L \Natural \to \Natural}
]
$$


$$
\begin{array}{lll}
  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C
  & \vdash
  & e C x_0 x_1 : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural}
  & \vdash
  & e C (s x_2) x_1 : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural},
  D^\Natural, x_3^D, x_4^{L D}
  & \vdash
  & e C (s (c D x_3 x_4) x_1 : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural},
  D^\Natural, x_3^D, x_4^{L D}
  & \vdash
  & e C (s (c D n a) x_1 : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural},
  D^\Natural, x_3^D, x_4^{L D}, x_5^\Natural, x_6^\Natural
  & \vdash
  & e C (s (c D n a) (p x_5 x_6) : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural},
  D^\Natural, x_3^D, x_4^{L D}, x_5^\Natural, x_6^\Natural,
  x_7^{L\Natural}
  & \vdash
  & e C (s (c D n a) (p x_5 (s x_7) : \Prop

  \\

  \Gamma, A^\Any, n^A, B^\Any, a^B, C^\Any, x_0^C, x_1^C, x_2^{L\Natural},
  D^\Natural, x_3^D, x_4^{L D}, x_5^\Natural, x_6^\Natural,
  x_7^{L\Natural}
  & \vdash
  & e C (s (c D n a)) (p n (s a)) : \Prop

\end{array}
$$
%

During the term building the following substitutions are produced
$$
\sigma = \left[
\begin{array}{ll}
  C:=\Natural
  \\ x_0:= s x_2      & x_0 := s (c \Natural n a)
  \\ D:=\Natural
  \\ x_2:=c D x_3 x_4 & x_2 := c \Natural n a
  \\ A := D           & A := \Natural
  \\ x_3 := n
  \\ B := L D         & B := L \Natural
  \\ x_4 := a
  \\ C := \Natural
  \\ x_1 := p x_5 x_6 & x_1 := p n (s a)
  \\ x_6 := s x_7     & x_6 := s a
  \\ x_1 := n
  \\ x_7 := a
\end{array}
\right]
$$



\subsubsection{Discussion of Simplification}


The simplification discussed in this section is
\begin{quote}
  At the end of term building all placeholders must have
  substitutions. Clearly all substitutions must not contain placeholders. The
  latter is guaranteed by the unification algorithm.
\end{quote}

In order to make no invalid substitutions we have to guarantee that no
substitution contains non-placeholder variables above the corresponding
placeholder. In the above example the only non-placeholder variables are $n$
and $a$. These two variables are contained only in the substitutions of the
placeholders which represent subterms. The reason for the substitutions is
that the variables occur within the terms.

Variables occuring in terms are be introduced before the placeholders
representing the subterms. Therefore it seems obvious that the variables can
occur only in placeholders representing subterms with the correct ordering.

The critical question is: Since the variables $n$ and $a$ are untyped, we
introduced the placeholders $A^\Any$ and $B^\Any$ representing the types of
$n$ and $a$ before the variables $n$ and $a$.
\begin{quote}
  Can the substitutions of $A$ and $B$ contain the variables $n$ and $a$?
\end{quote}
Hopefully not, because this would indicate some circularity. A variable must
never be contained in its own type!!!

The placeholders $A$ and $B$ get their substitutions only at places where the
corresponding variables $n$ and $a$ are used and therefore the placeholders
must be unified with the corresponding required types for $n$ and $a$. It is
very difficult to imagine how the variables $n$ and $a$ could \emph{creep
  into} the corresponding required types. This would mean that $n$ and $a$ had
been used within the forming of the required types i.e. they would have been
used before and would have already substitutions.

I.e. $A$ and $B$ get their substitutions at the first use of $n$ and $a$. If
$n$ and $a$ are arguments, their required types cannot contain the variables.

Remains the possibility that untyped variables occur in function positions. At
the moment I cannot imagine a useful situtation. It might be best to forbid
the occurrence of untyped variables in a function position and restrict the
occurrence of untyped variables to argument positions. This restriction
certainly avoids circularity.


\noindent Restrictions:
\begin{itemize}

\item All placeholders must get substitutions during term building. Otherwise
  the user is asked to provide some typing annotation or provide some type
  variables.

\item No untyped variable can occur in a function position before it has
  occurred in an argument position.

  Possible relaxation of the restriction: If an untyped variable occurs at
  least in an argument position, then the subterm where it occurs in an
  argument position is analyzed first. However this adds complexity which is
  not worth the effort.
\end{itemize}



\subsubsection{Untyped Arguments in Function Position}

What needs to be done if we allow untyped bound variables in function
positions. First we need a type variable i.e. a placeholder for the type.
$$
\Gamma, A^\Any, f^A, \ldots
$$
On the first occurrence of $f$ in a function position we have to introduce two
new type variables
$$
\Gamma, A^\Any, f^A, \ldots, B^\Any, C^\Any
$$
and do the unification $ A = \Pi x^B. C$ where $B$ cannot depend on $x$ and
$C$ can depend on $x$.

We see a difficulty here. There is no variable $x$ in the context.

\noindent Next difficulties:

$f$ could occur in different function positions with
different number of arguments.

There is no way to find the implicit arguments of the application.

Therefore: We allow untyped arguments only in function positions if they occur
before in argument positions. If they occur in argument positions, then we
have a type for the variable which is not inferable (because it is explicit)
and therefore can be analyzed for arity.


\begin{alba}
  -- legal
  union A (ps: Predicate (Predicate A)): Predicate A :=
    \ x := some p: ps p and p x  -- 'p' occurs first in argument position

  -- illegal
  union A (ps: Predicate (Predicate A)): Predicate A :=
    \ x := some p: p x and ps p   -- 'p' occurs first in function position

  -- legal with explicit type
  union A (ps: Predicate (Predicate A)): Predicate A :=
    \ x := some (p: Predicate A): p x and ps p
\end{alba}









%


\subsection{Requirements}

The input to the term builder:
%
\begin{enumerate}

\item A syntactic term from the source code

\item A context

\item An optional expected type
\end{enumerate}

Output of the term builder: Because of ambiguities the output is a list of the
following data
%
\begin{enumerate}

\item A term in the intermediate language whose type is the optional expected
  type.

\item An augmented context which contains in addition to the input context
  \begin{enumerate}
  \item Type variables which can be freely substituted with any type without
    disturbing the validity of the term. If there are free type variables the
    term is polymorphic. E.g. the term \code{nil A} has the free type variable
    \code{A:Any}. The user only writes \code{nil} but the term builder has to
    add the implicit argument. Since there is no way to determine it, it has
    to assume a type variable.
  \item Proof variables which are used in the term and which have to be
    substituted by the prover by concrete proofs.
  \end{enumerate}
\end{enumerate}


The required type of a syntactic term depends on where the term is positioned.
%
\begin{description}

\item[Top of the Repl]
  %
  The term does not have a required type. It can be anything: A type, an
  object, a sort, ...

\item[Type Annotation]
  %
  Examples:
  \begin{alba}
     reverse (A: Any) (l: List A): Specified (\r := r.is_reversal_of l)
       := ...

     \ (n:Natural): Natural := n + 1
  \end{alba}
   %
   In these examples all terms to the right of the colon \code{:} must be
   types. There is no requirement for the types except that they must be types
   i.e. their types must be sorts. Since we have no required type, we cannot
   introduce a variable to represent them.

 \item[Term with Type Annotation]
   %
   In the example
   \begin{alba}
     (3 + 4 / 8 * 3 : Natural) = list.length
   \end{alba}
   the term \code{3 + 4 / 8 * 3} has the type annotation
   \code{Natural}. Therefore the type annotation \code{Natural} is the
   required type for the term.

 \item[Function Definition]
   %
   If the term is the defining expression of a function definition and the
   result type of the function is specified, then the required type of the
   defining expression is the result type of the function.
   %
   \begin{alba}
     f (a:A) (b:B): R := exp
   \end{alba}

 \item[Argument]
   %
   An argument must be an argument of some function expression. The function
   expression has a type which clearly indicates the required types for the
   arguments. Therefore a syntactic expression in an argument position has a
   required type and we can introduce variables to represent the argument
   terms which we later substitute by the corresponding intermediate language
   terms.

 \item[Function]
   %
   In the syntactic term \code{f a b} the subterm \code{f} is in the function
   position. The required type of the whole expression is a required type for
   the return type of \code{f} i.e. the subexpression in the function
   position. Another requirement for the subterm \code{f} is that must be
   applicable to $n$ arguments.
\end{description}



\noindent In summary we have the requirements for a syntactic term
%
\begin{enumerate}

\item Required result type, which is either
  \begin{enumerate}

  \item nothing in the case of a toplevel expression in the repl

  \item some type, if the term is in a type annotation position (to the right
    of a colon)

  \item result type of a function definition or annotated type of an expression

  \item the type of a variable which has been introduced to represent the
    argument
  \end{enumerate}


\item Number of essential arguments (without implicit arguments and proof
  arguments). If the number of arguments is different from zero, then the term
  is in a function position.
\end{enumerate}







%
\subsection{Algorithm Data}


\noindent Input:

\begin{enumerate}

\item Nonempty list of

  \begin{enumerate}

  \item Context

  \item Set of all placeholders / Substitution

  \item Stack of placeholders representing not yet analyzed function arguments

  \item Number of arguments (to which the syntactic expression is applied) and
    the application mode (normal, target of object call, operand)

  \item Optional expected type
  \end{enumerate}

\item Syntactic expression
\end{enumerate}

Lists are needed because of ambiguity. All elements of the list have the same
number of arguments. If there is an expected type, there is one for all
elements. If the expected type is an arbitrary type, it is the same for all
list elements.

If no error occurs, then the algorithm outputs a nonempty list of:

\begin{enumerate}

\item Context

\item Set of all placeholders / Substitution

\item Stack of placeholders representing not yet analyzed function arguments

\item Term and its type in the intermediate language

\end{enumerate}

The context, set of placeholders, substitution and the stack of placeholders
are common elements of the input and output structure.






\subsection{Apply Terms to Arguments}
\label{sec:apply-terms-to_arguments}



Input: Number of explicit arguments, Expected type(s) of term applied to
arguments, list of term/type pairs of the term under consideration.

Every syntactic subterm might be applied to some arguments.

The analyis of the term returns a list of term/type pairs.

We analyze the types and get a list of argument descriptors where each
descriptor indicates what kind of argument it is: Proof argument, explicit
argument, implicit type constructor argument.

We introduce placeholders $a_0, a_1, \ldots$ for the explicit arguments
occurring in the syntactic term and all implicit arguments before, between and
after the actual explicit arguments.

Compute the type $T$ of the term
$$
t \, a_0 \, a_1 \, \ldots : T
$$
and unify it with the expected types. The expected type(s) do not contain any
placeholders which have been introduced in the analyis of the term $t$.

If unification is not successful or if the type of $t$ does not allow
sufficient arguments, then the term $t$ is not possible in that position.

If at the end no candicates remain, then a type error message has to be
generated.

Two kinds of error messages can be generated from this phase:
\begin{enumerate}
\item None of the terms can be applied to $n$ explicit arguments

\item There are some terms which can be applied to $n$ explicit arguments but
  the result type matches non of the expected types.
\end{enumerate}







\subsection{Terminal Elements}

The possible terminal elements (syntactic terms which have no subterms) of a
syntactic term are
%
\begin{enumerate}

\item Identifier / Operator

\item Number

\item Character

\item String

\item Sort (\code{Proposition} and \code{Any})
\end{enumerate}

Numbers, characters, strings and sorts cannot be applied to
arguments. Identifiers, operators and numbers can have ambiguous types.

The expected type is the type of the expression applied to the arguments.

\begin{enumerate}

\item Get a list of term/type pairs. Examples
  \begin{itemize}

  \item 125: [125:Natural, 125:Nat, 125:Int, 125:Float, 125:Byte]

  \item 'a': ['a':Character, 'a':Byte]

  \item ``Hello'': [``Hello'':String, ``Hello'':Byte\_string]

  \item (+): [(+):$\Natural\to \Natural\to \Natural$, (+): String $\to$ String
    $\to$ String, ...]

  \item reverse: [reverse: all A: List A $\to$ List A]

  \item $\Prop$: [$\Prop:\Any_0$]

  \item $\Any$: [$\Any_0:\Any_1$]

  \end{itemize}

\item Apply arguments.
\end{enumerate}



\subsection{Function Application}

A function application has the forms

\begin{alba}
  f a b c ...        -- normal mode

  a.f b c ...        -- oo style mode

  a binop b          -- operator expression
\end{alba}


\begin{enumerate}

\item Analzye $f$ and get $f x y \ldots$ and the placeholders on the stack
  which represent the arguments.


\item For each argument $a_i$ do
  \begin{enumerate}

  \item Pop one placeholder $(x_i,A_i)$ off the stack and use $A_i$ as a
    required type for $a_i$.

  \item Analyze $a_i$ with zero arguments and get the corresponding term
    $t_{a_i}$ as a result.

  \item Substitute $x_i$ with $t_{a_i}$.

  \end{enumerate}

\item Return $f x y \ldots$.

\end{enumerate}






\subsection{Function Term / Abstraction}

A function term has the possible forms

\begin{alba}
  \ x y ... := exp                     -- without types

  \ (x:A) (y:B) ... : R := exp         -- fully typed

  (a +)                                -- section '\x := a + x'

  (+ a)                                -- section '\x := x + a'
\end{alba}


For unknown argument types we have to introduce type variables into the context.

For
\begin{alba}
  \ x y (z:C) := exp
\end{alba}
%
we need the context
$$
    \Gamma, A^{\Any_1}, x^A,  B^{\Any_1}, y^B, z^C \ldots
$$
%
where the two placeholder type variables $A$ and $B$ have been introduced to
describe the types of the variables $x$ and $y$.

The type $C$ might contain the variables $x$ and $y$ (e.g. \code{C = x < y})
i.e. the analysis of $C$ might already determine the type variables $A$ and
$B$.

Finally we analyze the expression \code{exp} in the new context and get an
intermediate language term $e:E$ in the context.

At the end some unassigned type variables can remain. We shift them all to the
left of $x:A$ and form $\lambda x^A y^B z^C . e : \Pi x^A y^B z^C . E$ in the
context below $x$.

During the analysis of \code{exp} it is possible that some proof variables
like $x_p:p$ have been introduced. The actual proof has not yet been
generated, but it might depend on $x,y,z$. In order to eliminate $x_p$ we
introduce a new proof variable $y_p:\Pi x^A y^B z^C . p$ to the left of $x:A$
and substitute $x_p$ by $y_p x y z$.

Now we analyze $\Pi x^A y^B z^C . E$ with respect to the number of variables
to which the function term is applied and unify the result type with the
expected type.



A function term might be potentially recursive
\begin{alba}
  f x y := exp
\end{alba}
where \code{f} might occur in \code{exp}

In that case we need a context like
$$
  \Gamma, A^{\Any_1}, B^{\Any_1},  R^{\Any_1}, f^{\Pi x^A y^B.R}, x^A, y^B
$$
%
to analyze \code{exp} with the expected type $R$.

Suppose $e:E$ is the result of the analysis of \code{exp} and $f$ occurs in
$e$. Then we have to find the decreasing argument which decreases in each
recursive call.

There is a special case that each usage of $f$ is a function call with fewer
arguments than there are formal arguments in the declaration \code{f x
  y}. That case has to be investigated more in detail (TBD!!).

In case of success the result of the analysis of the function expression is
$\fix(f^{\Pi x^A y^B. R}, e, k) : \Pi x^A y^B. R$.





\subsection{Function Type}


\begin{alba}
  all x y ... : exp

  all (x:A) (y:B) ... : exp

  all (x:A) : B -> ... -> Z        -- all (x:A) (_:B) ... : Z
\end{alba}

If there is an expected type for the whole expression, then it must be a sort
i.e. either $\Prop$ or $\Any$ because an expression of the form \code{all x
  y:exp} is always a type and the type of a type is a sort.

As in the analysis of a function term we have to introduce type variables for
the untyped variables into the context.
$$
\Gamma, A^{\Any_1}, x^A, B^{\Any_1}, y^B, \ldots
$$
%
In this context we analyze \code{exp} expecting some type (note that
\code{exp} is to the right of a colon) or $\Prop$ if the expected type of the
whole expression is $\Prop$.





\vskip 5mm
\subsection{Let and Where Constructs}



\begin{alba}
  exp where               -- 'exp' can contain 'a' and 'b'
    b x y := bexp         -- 'bexp' can contain 'a' (and 'b')
    a z := aexp           -- 'aexp' does not contain 'b', but maybe 'a'

  -- or
  let
    a z := aexp
    b x y := bexp
  in
    exp

  -- equivalent to
  (\a := (\b := exp) (b x y := bexp)) (a z := aexp)

  -- reduces to
  exp[a:=aexp][b:=(b x y := bexp)[a:=(a z := aexp)]]
\end{alba}

Only if \code{b} does not contain \code{a} we have the following equivalent
expression.

\begin{alba}
  (\a b := exp) (a z := aexp) (b x y := bexp)

  -- reduces to
  exp[a:=(a z := aexp)][b:=(b x y := bexp)]
\end{alba}



\vskip 5mm
\subsection{Pattern Match}

\begin{alba}
  inspect
    e
  case
    p1 := r1
    p2 := r2
    ...
\end{alba}


\vskip 5mm
TBD
\vskip 5mm




\newpage
\section{Draft}

\subsection{Unification}

We introduce placeholders for

\begin{enumerate}

\item Proof arguments in function applications.

\item Inferable type (or type constructor) variables in function applications.

\item Types of untyped variables in binders ($\lambda x^A . e$, $\Pi x^A
  . B$). Both need a type variable $A^{\Any_1}$. The type of the variable $A$
  is introduced as $\Any_1$ in order to be able to instantiate $A$ with
  $\Prop$ or $\Any_0$.

  The type variable $A$ will be instantiated if $x$ occurs as a proper subterm
  in $e$ or $B$ or if $\lambda x . e$ has a required type which is not a
  placeholder.

\end{enumerate}


The unification might add to the vector of substitutions
$$
\sigma = [y_0 : a_0, y_1 : a_1, \ldots]
$$
where $y_i$ are placeholders. Each placeholder $y_i$ is a variable $x_j$ in
the context. Placeholders which have a substitution can be eliminated from the
context.

Invariant: Substitutions $a_i$ of the placeholder $y_i$ which is the variable
$x_j$ must not contain variables $x_k$ with $j \le k$. This consistency
condition guarantees that no type in the context contains \emph{future}
variables after substitution.


The substitution lemma
$$
\rulev
{
  \Gamma,x^A,\Delta \vdash t : T
  \\
  \Gamma \vdash a: A
}
{\Gamma, \Delta[x:=a] \vdash t[x:=a] : T[x:=a]}
$$
is the theoretical foundation. I.e. each substitution must be valid in the
context before the placeholder variable.





\newpage
\section{Type Inference (Old material)}

\subsection{Basics}

A global (constant or function) is uniquely found by its name and its
signature. Many globals can share the same name as long as their signature is
different.

Looking up the name results in a list of globals. If the list is empty, then a
global with that name does not exist.

Locals shadow all previously declared names. I.e. either one local or a list
of globals is returned by looking up a name.

In an expression a name is used with a certain number of essential arguments
(i.e. with an arity at its call site). This has to be compared with the actual
arity. The actual arity must be sufficient for the required arity at the call
site.

If the arity is sufficient, the formal arguments can be pushed into the
context and a type remains as the result type which must be unified with the
required result type (possibly instantiating substitutable type variables).


\paragraph{Look up a global} It is a function call with $n$ essential
arguments. The $n$ arguments and the corresponding type variables and proof
arguments can be extracted and pushed into the \emph{global} context with
dummy variables. If the global is not unique we get more than one context. The
context might have different inferable variables and different types for the
dummy variables.

\paragraph{Required types}
If it is explicitly given (result type of a function in a function definition
or explicitly typed expression), then it is only one type and not a set of
types.

If the expression is used as an argument of a function, then there can be
multiple required types. Anyhow, we have a context (or a set of contexts) and
for each context an explicit type or a pointer to an argument (whose type is
the required type).




\subsection{Unification}


A system of equations is in a \emph{solved form} iff it has the following
properties
%
\begin{enumerate}

\item All equations have the form $x = t$ where $x$ is a variable.

\item A variable that occurs on the left-hand side of an equation does not
  occur at the right-hand side of any equation.

\item A variable may occur only on one left-hand side.
\end{enumerate}

The system
$$
%
\begin{array}{lll}
  x &=& f\, y
  \\
  y &=& g\, x
\end{array}
$$
%
can be made inconsistent by substituting the second equation into the first
getting $x = f (g\, x)$ where $x$ occurs on the left and on the right-hand side.

The system
$$
\begin{array}{lll}
  x &=& f\, y
  \\
  y &=& g\, z
  \\
  z &=& c
\end{array}
$$
%
where $c$ does not contain any variables can be transformed into the solved
form
$$
\begin{array}{lll}
  x &=& f\, (g \, c)
  \\
  y &=& g\, c
  \\
  z &=& c
\end{array}
$$
%
because it has no circularity.

The non-circularity can be maintained easily on a system in solved
form. Assume we have
$$
%
\begin{array}{lll}
  x &=& t_x
  \\
  y &=& t_y
\end{array}
$$
%
in solved form (i.e. $t_x$ and $t_y$ contain neither $x$ nor $y$) and we want
to add a new equation $z = t_z$. We just use
$$
%
\begin{array}{lll}
  x &=& t_x[z := t_z]
  \\
  y &=& t_y[z := t_z]
  \\
  z &=& t_z[x,y := t_x, t_y]
\end{array}
$$
%
and check if any of the variables occurs on the right-hand side of its
equation. The system remains consistent if $t_z$ does not contain $x,y$ or if
$t_x,t_y$ do not contain $z$.


Question: Is it possible to avoid circularity without transforming the system
into the solved form on each step? Let's assume we have
$$
%
\begin{array}{lll}
  x &=& t_x
  \\
  y &=& t_y
\end{array}
$$
%
which is solvable i.e. $t_x$ does not contain $y$ or $t_y$ does not contain
$x$ and we want to add a new equation $z = t_z$. $z$ might be contained in
$t_x$ and/or $t_y$ and $x$ or $y$ might be contained in $t_z$.




\subsection{Type Safe Unification}

Since we have a well typed system it might be possible that circularity during
unification is impossible due to the typing rules.

Assume that $A$ is a type variable and during unification we get the equation
$A = L\, A$ where $L$ is any type constructor (e.g. \code{List}). Since we can
substitute equals for equals we would get the infinite chain
$$
  A = L\, A = L\, (L\, A) = L\, (L\, (L\, A)) \ldots
$$



Example: We want to build a term for the syntactic expression $a + b * c$ in
the context $\Gamma$. This is possible only if the variables $a, b, c, +, *$
occur in $\Gamma$ i.e. we assume a context
$$
\Gamma = [+^{I\to I\to I}, *^{I\to I\to I}, \ldots, a^I, b^I, c^I, \ldots]
$$


We don't know the type of the expression nor a term which
represents the expression. We add two unknows (i.e. variables) to the context.
%
$$
\Gamma, E^\Any, e^E
$$
%
Now we have to analyze $\cdot + \cdot$ as a binary operator i.e. a function
with two arguments. In the context we have $+^{I \to I \to I}$ where $I$
represents the type of integer numbers.

We need a placeholder of type $I$ for each argument and get
$$
%
\Gamma,  E^\Any, e^E, u^I, v^I \vdash u + v: I
$$
%
We unify $e^E$ with $(u+v)^I$ and get the system
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
\end{array}
$$
%
Next we analyze the expression $a$ which is not a function call and therefore
does not need new placeholders.
$$
%
\Gamma,  E^\Any, e^E, u^I, v^I \vdash a:I
$$
%
Unification of $u^I$ and $a^I$ leads to
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
\end{array}
$$
%
Next we analyze $\cdot * \cdot$ and need again two new placeholders
$$
%
\Gamma,  E^\Any, e^E, u^I, v^I, w^I, x^I \vdash w * x: I
$$
%
and unify $v^I$ with $ (w * x)^I$ to get
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
  \\
  v &=& w * x
\end{array}
$$
%
Continuing the process we finally get
$$
%
\Gamma,  E^\Any, e^E, u^I, v^I, w^I, x^I
$$
%
with
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& u + v
  \\
  u &=& a
  \\
  v &=& w * x
  \\
  w &=& b
  \\
  x &=& c
\end{array}
$$
%
This system can be resolved into
$$
%
\begin{array}{lll}
  E &=& I
  \\
  e &=& a + b * c
  \\
  u &=& a
  \\
  v &=& b * c
  \\
  w &=& b
  \\
  x &=& c
\end{array}
$$
%
where only the first two lines are interesting.





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main_alba_design"
%%% End:
