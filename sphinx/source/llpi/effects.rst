***************
Effects
***************



A trace is a sequence of io or runtime events. Examples of events:

- Opening of a file with name, mode and filedescriptor.
- Allocation of a buffer with a certain size.
- Reading from a file into a buffer or writing into a file from a buffer.
- Closing a file
- Query the status of a filedescripor (is open, name, mode).






IO Monad
========


In order to illustrate the key ideas in a simple setting we use as a type for
partial programs the type ``IO α`` where ``α`` is the type of the value which
the partial program returns.

We encode ``IO`` as a state monad where the state is the sequence of events. The
sequence of events are stored in a list where the most recent events are the
first elements in the list. Pushing an event to the front of the list means that
the program executes the corresponding action.

A partial program of type ``IO α`` is a function which maps the events which
have already occurred previously to a pair consisting of a return value and the
additional events which it executes.


.. code-block:: alba

    Event: Any                  -- type of runtime events
    Trace := List Event         -- first events are the most recent

    -- Haskell style IO monad
    IO {α: Any}: Any :=
            -- Map occurred events to a return value and additional events.
        Trace → (α, Trace)

    -- return and bind operations
    return {α: Any} (a: α): IO α :=
        λ _ := (a, [])       -- no new events.

    bind {α β: Any} (m: IO α) (f: α → IO β): IO β :=
        λ t₁ :=
            inspect m t₁ case
                λ (t₂, a) :=
                    f a (t₂ + t₁)   -- most recent additional events first!


In this setting it is not possible to specify preconditions for the partial
programm, nor is it possible to specify the return value and events generated by
the partial programm.


Specifications
==============

A specification of a complete program is a predicate over its trace. Programs
are deterministic. Nondeterminism arises from the environment. E.g. we can ask
the runtime system to generate a random number. This is a nondeterministic
action (or at least it should look like nondeterministic). However the program
reacts deterministically to the generated number. Furthermore the operating
system can reject an open request for a file or it can open it successfully.
Regardless on what happens. The program reacts deterministically.

According to Tony Hoare's ``CSP`` a deterministic process can be completely
specified by its valid traces i.e. in that case by its interactions with the
runtime system aka traces.

We compose a program by from elementary actions to more complex actions. We
might first do some sequence of actions and then some other sequence of actions.
Each action can depend on some preconditions (e.g. that a file has been
successfully opened for reading) before it can start.

Such a precondition is a predicate over the trace of the previous events. Then
it executes and return some value and accumulates more events to the trace.

I.e. a specification of a program is a transition which is a predicate over the
trace before the start, the return value and the additional events generated.

.. code-block:: alba

    Specification (α: Any): Any :=
        Trace → α → Trace → Proposition

Certain triples ``(t1, a, t2)`` are valid. The specification characterizes the
valid triples.

A specification is implicitly a specification of its precondition. A start trace
``t1`` satisfies the precondition if there are some pairs ``(a, t2)`` such that
``(t1, a, t2)`` satisfies the specification.

.. code-block:: alba

    class
        Precondition
            {α: Any}
            (S: Specification α)
            (t₁: Trace)
        : Proposition
    :=
            -- 't₁' satisfies the precondition of a program with
            -- specification 'S'.
        precondition {a t2}: S t₁ a t₂ → Precondition.

If we have an inhabitant of ``Precondition S t₁``, then we know that there are
pairs ``(a, t₂)`` such that ``(t₁, a, t₂)`` satisfies the specification ``S``.


At the end of a program fragment a certain value can be returned and some
additional events might have been generated. A specification specifies the valid
pairs ``(a, t2)`` for some start trace ``t1``.


.. code-block:: alba

    class
        Postcondition
            {α: Any}
            (P: α → Trace → Proposition)
        : Proposition
    :=
            postcondition {a t₂}: P a t₂ → Postcondition


An inhabitant of ``Postcondition P`` is a pair ``(a t₂)`` and a proof of ``P a
t₂``.



The specification for ``return a`` says the partial program just returns ``a``
and does not produce any new events.

.. code-block:: alba

    Return {α: Any} (a: A): Specification α :=
        λ t₁ x t₂ :=
            a = x /\ t₂ = []


Now let us find a specification for ``bind c f`` where ``c`` has a specification
and and there is a type constructor ``F`` which maps the return value of ``c``
into a specification. I.e. we want a ``Bind`` with the signature



.. code-block:: alba

    Bind
        {α β: Any}
        (S₁: Specification α) (F: α → Specification β)
    : Specification β

The input for ``Bind`` is a specification of the first partial computation and
function which maps the return value of the first partial program into a
specification. The output is a specification for the combined partial program.



.. code-block:: alba

    Bind
        {α β: Any}
        (S₁: Specification α) (F: α → Specification β)
    : Specification β
    :=
        λ t₁ b t₃ :=
            Postcondition (S₁ t₁)
            ∧
            ∀ a t₂: S₁ t₁ a t₂ → Postcondition (F a (t₂ + t₁))


.. code-block:: alba

    Bind
        {α β: Any}
        (S₁: Specification α) (F: α → Specification β)
    : Specification β
    :=
        λ t₁ b t₃ :=
            Precondition S₁ t₁
            ∧
            ∀ a t₂: S₁ t₁ a t₂ → F a (t₂ + t₁)


.. code-block:: alba

    Bind
        {α β: Any}
        (S₁: Specification α) (F: α → Specification β)
    : Specification β
    :=
        λ t₁ b t₃ :=
            Postcondition
                (λ a t₂ :=
                    S₁ t₁ a t₂ ∧ F a t₂ b t₃) 
