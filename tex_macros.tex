\lstdefinelanguage{alba}
{ basewidth=0.45em,
  basicstyle=\small\tt,  % choices: small, footnotesize, scriptsize, tiny
  mathescape,
  %columns=flexible,
  keywords={
    abstract,all,and,assert,
    case,class,create,
    do,
    else,end,explicit_arguments,
    ghost,
    if,in,inherit,inspect,
    let,
    mod,
    mutual,
    not,
    or,
    record, require,
    section,some,
    then,
    use,
    via,
    where,
    And,
    Not,
    Or
  },
  keywordstyle=\color{blue},
  commentstyle=\color{brown},
  morecomment=[l]{--},
  morecomment=[n]{\{-}{-\}}
}

\lstnewenvironment{alba} {\lstset{language=alba}} {}







\lstdefinelanguage{ocaml}
{ basewidth=0.45em,
  basicstyle=\tt\small,
  %columns=flexible,
  keywords={
    and,assert,
    do,done,
    else,end,
    for,fun,function,functor,
    if,in,include,
    let,
    match,module,mutable,
    of,
    rec,ref,
    sig,struct,
    then,to,type,
    val,
    when,while,with},
  keywordstyle=\color{blue},
  commentstyle=\color{brown},
  morecomment=[n]{(*}{*)}
}

\lstnewenvironment{ocaml} {\lstset{language=ocaml}} {}





\lstdefinelanguage{js}
{ basewidth=0.45em,
  basicstyle=\small\tt,
  %columns=flexible,
  keywords={
    class,
    else,extends,
    for,function,if,
    return,
    this,
    var},
  keywordstyle=\color{blue},
  commentstyle=\color{brown},
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/}
}

\lstnewenvironment{js} {\lstset{language=js}} {}




\newcommand{\code}[1]{{\tt\small #1}}

\def\ignore#1{}

\def\vec0#1{{\vec{#1}}}
\def\vec#1{{\overrightarrow{#1}}}
%\def\vec#1{\mathbf{#1}}
\def\meta#1{{}^?\!#1}
\def\set#1{\{#1\}}

\def\Abold{\mathbf{A}}
\def\abold{\mathbf{a}}
\def\Bbold{\mathbf{B}}
\def\bbold{\mathbf{b}}
\def\Cbold{\mathbf{C}}
\def\Dbold{\mathbf{D}}
\def\fbold{\mathbf{f}}
\def\Pbold{\mathbf{P}}
\def\pbold{\mathbf{p}}
\def\qbold{\mathbf{q}}
\def\Tbold{\mathbf{T}}
\def\tbold{\mathbf{t}}
\def\xbold{\mathbf{x}}
\def\ybold{\mathbf{y}}
\def\zbold{\mathbf{z}}


\def\Abstract{{\cal{A}}}
\def\Prop{{\cal{P}}}
\def\Any{{\cal{A}}}
\def\Universe{{\cal{U}}}
\def\Boolean  {{\mathbb{B}}}
\def\Decision {{\mathbb{D}}}
\def\List   {{\mathbb{L}}}
\def\Natural{{\mathbb{N}}}

\def\max   {\text{max}}
\def\case  {\text{case}}
\def\fix   {\text{fix}}
\def\ind   {\text{ind}}
\def\strip {\text{strip}}
\def\where {\text{where}}

%\def\Inductive    {\mathbb{I}}
%\def\Constructor  {\mathbb{C}}
\def\Inductive    {{\cal I }}
\def\Constructor  {{\cal C}}


\def\floor#1{\left\lfloor #1 \right\rfloor}
\def\bla#1#2{#1 #2}

\def\intdiv#1#2{\floor{\frac{#1}{#2}}}


\def\unify{\simeq}
\def\unifysub{\precsim}
% other possibilities: \equiv, \approx, \cong, \simeq, \doteq, \precapprox,
% \precsim, \lesssim, \gtrsim


\def\imp{\Rightarrow}
\def\reduce{{\,\triangleright\,}}
\def\reducekey{{\,\triangleright_\text{key}\,}}
%\def\reduce{{\mathrel{\triangleright}}}
%\def\reducekey{\reduce_\text{key}}
\def\bind{{>\!\!\!>\!\!=}}
\def\caret{\mathrel{\hat{\ }}}
\def\carettext{\^\ }
\def\notparallel{{\not\parallel}}

\def\lemust{{\,\stackrel{!}{\le}\,}}
\def\ltmust{{\,\stackrel{!}{<}\,}}
\def\eqmust{{\,\stackrel{!}{=}\,}}
\def\relmust#1{{\,\stackrel{!}{#1}\,}}
\def\ctype#1#2#3#4{#1 \vdash #2 \; |_{#3} \, #4}

\def\mybackslash{{\char`\\}}
\def\mytilde{{\char`\~}}

\newcommand{\ruleh}[2]{\begin{array}{c} #1 \\ \hline #2\end{array}}
\newcommand{\rulev}[2]{\begin{array}{l} #1 \\ \hline #2\end{array}}

\theoremstyle{definition} \newtheorem{definition}{Definition}[section]
\theoremstyle{definition} \newtheorem{theorem}[definition]{Theorem}
\theoremstyle{definition} \newtheorem{lemma}[definition]{Lemma}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main_alba_design"
%%% End:
