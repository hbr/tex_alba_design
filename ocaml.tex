\chapter{Ocaml}


\section{Some Constructs}

\begin{ocaml}
  (* the 2 declarations are equivalent *)
  apply (f:'a -> 'b) (a:'a): 'b =
    f a

  apply (type a) (type b) (f:a -> b) (a:a): b =
    f a
\end{ocaml}


\section{Trampolines}

\begin{ocaml}
  (* implement trampolining *)
  type 'a bounce = Done of 'a | Call of (unit -> 'a bounce)

  let rec trampoline = function  (* tail recursive function *)
    | Call thunk -> trampoline (thunk())
    | Done x     -> x

  (* define some functions which use them *)
  let rec
    even n = if n = 0 then (Done true) else (Call (fun () -> odd (n-1)))
  and
    odd n = if n = 0 then (Done false) else (Call (fun () -> even (n-1)))

  (* test them out *)
  let _ =
    assert (trampoline (even 0) = true );
    assert (trampoline (even 1) = false);
    assert (trampoline (even 2) = true );
    assert (trampoline (even 3) = false);

    assert (trampoline (odd 0) = false);
    assert (trampoline (odd 1) = true);
    assert (trampoline (odd 2) = false);
    assert (trampoline (odd 3) = true);
\end{ocaml}





\section{First Class Modules}


\begin{ocaml}
  let string_module: (module ANY) = (module String)

  let dummy (i:(module ANY)): unit =
    let module M = (val i) in
    let open M in
    ()

  let dummy2 (module M:ANY): unit =
    let open M in
    ()

  let _ = dummy string_module
\end{ocaml}


\begin{ocaml}
  module type IMOD =
    sig
      val value: int
    end

  let set_imod (v:int): (module IMOD) =
    let module I =
      struct
        let value: int = v
      end in
    (module I)

  let get_imod (module I:IMOD): int =
    I.value
\end{ocaml}





\section{Continuations}

Classical implementation of a continuation monad:
%
\begin{ocaml}
  module Continuation (A:ANY) =
  struct
    type answer = A.t
    type 'a t = ('a -> answer) -> answer
    let return (a:'a) (k:'a -> answer): answer =
      k a
    let (>>=) (m:'a t) (f:'a -> 'b t) (k:'b -> answer): answer =
      m (fun a -> f a k)
    let run (m:answer t): answer =
       m identity
  end
\end{ocaml}
%
or maybe better
\begin{ocaml}
  module Continuation (A:ANY) =
  struct
    type answer = A.t
    type 'a t = ('a -> answer) -> answer
    let return (a:'a): 'a t =
      fun k -> k a
    let (>>=) (m:'a t) (f:'a -> 'b t): 'b t =
      fun k -> m (fun a -> f a k)
    let run (m:answer t): answer =
       m identity
  end
\end{ocaml}

Let's assume we have
\begin{ocaml}
   module C = Continuation (Int)
   let m = return 0 >>= fun i -> return (i + 1) >>= fun i -> return (i + 1)
\end{ocaml}
%
which can be constructed step by step
\begin{ocaml}
  return 0 >>= f1
  =
  fun k -> return 0 (fun a -> f1 a k)
  =
  fun k -> return 0 (fun a -> (fun i -> return (i+1) >>= f2) a k)
  =
  fun k -> return
             0
             (fun a -> (fun i ->
                          fun k ->
                            return
                              (i+1)
                              (fun a -> f2 a k)
                       ) a k)
  =
  fun k -> return
             0
             (fun a -> (fun i ->
                          fun k ->
                            return
                              (i+1)
                              (fun a -> (fun i -> return (i+1)) a k)
                       ) a k)
\end{ocaml}
%
The call stack can get excessively deep in running a continuation monad.

Now we try a different design
%
\begin{ocaml}
  module Continuation (A:ANY) =
  struct
    type answer = A.t
    type state =
      | Done of answer
      | More of (unit -> state)
    ...
  end
\end{ocaml}
%
and we define the monadic type
\begin{ocaml}
  type 'a t = ('a -> state) -> state
\end{ocaml}
%
and the basic monadic functions
\begin{ocaml}
  let return (a:'a): 'a t =
    fun k -> k a

  let (>>=) (m:'a t) (f:'a -> 'b t): 'b t =
    fun k -> m (fun a -> More (fun () -> f a k))
\end{ocaml}
%
having this the function \code{run} can be implemented iteratively
\begin{ocaml}
  let run (m: answer t): answer =
    let st = ref (m (fun a -> Done a))
    and goon = ref true
    in
    while !goon do
      match !st with
      | Done _ ->
         goon := false
      | More f ->
         st := f ()
    done;
    match !st with
    | Done a ->
       a
    | _ ->
       assert false (* cannot happen *)
\end{ocaml}
%
With this design no deeply nested call stack occurs.


%%%Local Variables:
%%% mode: latex
%%% TeX-master: "main_alba_design"
%%% End:
