
\chapter{Certified Programming}
\label{chap:certprog}





\newpage
\section{Logic}
\label{sec:certprog-logic}


\subsection{Negation}

Negation is defined in the prelude as
\begin{alba}
  (not) (a: Proposition): Proposition :=
    a => false
\end{alba}

We want to prove the contrapositive law of logic which states
\begin{alba}
  (a => b) => not b => not a
\end{alba}
for all propositions \code{a} and \code{b}. A proof of that fact would be
written in Alba as the function
%
\begin{alba}
  contrapositive a b (ab: a => b) (nb:not b): not a :=
    _      -- compiler, please generate a proof of 'not a'!
\end{alba}
%
It is not necessary to write such a proof by hand, because the compiler can
generate such a proof automatically. But if you want to write the proof
explicitly it looks like

\begin{alba}
  contrapositive a b (ab: a => b) (nb: not b): not a :=
    \ pa :=
        explicit_arguments
          nb (ab pa)
\end{alba}

\noindent Explanation: A proof of \code{not a} is a function which maps a
proof of \code{a} into a proof of false. If we have a proof of \code{a} we can
use the argument \code{ab} which maps a proof of \code{a} into proof of
\code{b} and then use \code{nb} which maps a proof of \code{b} into a proof of
\code{false} which is the desired result.

Since proof arguments are implicit in Alba, we have to use the keyword
\code{explicit\_argmuments} to give them explicitly.




\subsection{Disjunction}

Logical dijunction is defined in the prelude as the inductive type
%
\begin{alba}
  class
    (or) (a b: Proposition): Proposition
  create
    left:  a => a or b
    right: b => a or b
\end{alba}


\begin{alba}
  swap_or a b (p:a or b): b or a :=
    explicit_arguments
      inspect
        p
      case
        left  pa := right pa
        right pb := left  pb
\end{alba}

\begin{alba}
  eliminate_or a b c (ab: a or b) (ac: a => c) (bc: b => c): c :=
    explicit_arguments
      inspect
        ab
      case
        left  pa :=
          ac pa
        right pb :=
          bc pb
\end{alba}


\subsection{Conjunction}

\begin{alba}
  class
    (and) (a b: Proposition): Proposition
  create
    conjunction: a => b => a and b
\end{alba}


\begin{alba}
  swap_and (a b: Proposition) (p:a and b): b and a :=
    explicit_arguments
      inspect
        p
      case
        conjunction _ _ pa pb := conjunction b a pb pa
\end{alba}


\begin{alba}
  eliminate1_and (a b: Propositon) (p: a and b): a :=
    inpect p case
      conjunction _ _ pa pb := pa
\end{alba}







\newpage
\section{Relations}
\label{sec:certprog-relations}


\subsection{Basic Properties}


In the following we consider endorelations i.e. binary relations where both
domains are the same. For endorelations we can define what it means to be
reflexive, transitive and symmetric.

\begin{alba}
  is_reflexive (A:Any) (r: Endorelation A): Proposition :=
    all a: r a a

  is_transitive (A:Any) (r: Endorelation A): Proposition :=
    all a b c: r a b => r b c => r a c

  is_symmetric (A:Any) (r: Endorelation A): Proposition :=
    all a b: r a b => r b a
\end{alba}


Next we define the transitive closure of a relation.

\begin{alba}
  class
    plus (A:Any) (r: Endorelation A): Endorelation A
      -- 'plus r' is the transitive closure of 'r'
  create
    init a b:
      r a b
      => plus r a b
    step a b c:
      r a b
      => plus r b c
      => plus r a c
\end{alba}

The definition uses an inductive type. It uses two constructors. The
\code{init} constructor allows us to conclude \code{plus r a b} from \code{r a
  b}.
The \code{step} constructor allows us to conclude \code{plus r a c} from
\code{r a b} and \code{plus r b c}.

By intuition we see that the relation \code{plus r} is transitive. But in
order to be sure we need a proof. In order to proof transitivity we have to
prove
%
\begin{alba}
  plus r a b => plus r b c => plus a c
\end{alba}
%
i.e. we need a function which looks like
%
\begin{alba}
  f a b c (pab: plus r a b) (pbc: plus r b c): plus r a c :=
    ...
\end{alba}
%
In order to this we can do an induction proof on \code{pab: plus r a b} which
generates two cases.

One case is that \code{plus r a b} has been constructed
by \code{init a b rab}. In that case we can use the step constructor with
\code{ab: r a b} and \code{pbc: plus r b c} to construct \code{plus r a c}.

The second case is that  \code{plus r a b} has been constructed by \code{step
  a x b (ax: r a x) (pxb: plus r x b)}. Now we can use the induction
hypothesis to construct from \code{pxb} and \code{pbc} a proof of \code{plus r
  x c} and then the step constructor to generate a proof of \code{plus r a c}.


\begin{alba}
  plus_transitive A (r:Endorelation A): (plus r).is_transitive :=
    f a b c (pab: plus r a b) (pbc: plus r b c): plus r a c :=
      inspect
        pab
      case
        init a b :=   -- implicit argument '_: r a b'
            -- a -> b +> c
          step a b c

        step a x b :=
            -- implicit arguments _:  r a x
            --                    _: plus r x b
            {: goal: a -> x +> b +> c
               by a recursive call to f we prove x +> c
               and then use the step constructor to prove a +> c :}
          step a x c
          where
             _: plus r x c := f x b c
\end{alba}



In the same manner as the transitive closure we can define the reflexive
transitive closure of a relation.

\begin{alba}
  class
    star (A:Any) (r: Endorelation A): Endorelation A
      -- 'star r' is the reflexive transitive closure of 'r'
  create
    init a:
      star r a a

    step a b c:
      r a b
      => star r b c
      => star r a c
\end{alba}

Having the definition we prove that the reflexive transitive closure is
transitive.

\begin{alba}
  star_transitive A (r:Endorelation A): (star r).is_transitive :=
    f a b c (sab: star r a b) (sbc: star r b c): star r a c :=
      inspect
        sab
      case
        init a :=
          sbc
            -- a = b in this case

        step a x b :=
          step a x c
            -- using induction hypo: f x b c: star r x c
\end{alba}


\subsection{Diamonds and Confluence}


A relation is a diamond if it is always possible to join two steps with a
single step.

\begin{alba}
  is_diamond A (r: Endorelation A): Proposition :=
      {:   a  ->  b
           |      |
           v      v
           c  -> some d :}
    all a b c:
      r a b
      => r a c
      => some d: r b d and r c d
\end{alba}


A relation is confluent if its reflexive transitive closure is a diamond.

\begin{alba}
  is_confluent A (r: Endorelation A): Proposition :=
    (star r).is_diamond
\end{alba}



We prove that a diamond relation is confluent. Before doing that, we prove a
stripe lemma.

\begin{alba}
  stripe_lemma
    A
    (r: Endorelation A)
    (rdia: r.is_diamond)
    : all a b c:                       --  a *> b
        star r a b =>                  --  |    |
        r a c =>                       --  v    v
        some d: r b d                  --  c *> d?
                and
                star r c d :=
     f a b c sab rac :=
       inspect sab case   -- a = b, therefore we use d = c as witness
         init a :=
           _: some d: r a d and star r c d  where
             _: star r c c := init c

         step a x b :=
           {:  a  -> x  *> b
               |     |     |
               v     v     v
               c  -> e? *> d? :}
           _ where
             exist_d: some d: r b d and star r e d := f x b e
             exist_e: some e: r x e and r c e      := rdia a x c
\end{alba}

Then we can prove that a diamond relation is confluent.

\begin{alba}
  diamond_is_confluent
    A
    (r: Endorelation A)
    (rdia: r.is_diamond)
    : r.is_confluent
    :=
      f a b c sab sac: exist d: star r b d and star r c d :=
        inspect sab case
          init a :=            -- a = b, therefore we can use d = c
            _ where            --        as witness
              _: star r b c := sac
              _: star r c c := init c

          step a x b :=
            {:  a  ->  x  *>  b
                *      *      *
                v      v      v
                c  ->  e? *>  d? :}
            _ where
              exist_d: some d: star r b d and star r e d := f x b e
              exist_e: some e: star r x e and r c e := stripe_lemma r a c x

\end{alba}




\newpage
\section{Lists}
\label{sec:certprog-lists}


In the following we use the definition of the list type from the prelude.

\begin{alba}
  class
    List (A:Any): Any
  create
    [] : List A
    (^): A -> List A -> List A
\end{alba}
%
Note that the operator $\caret$ is right associative and has the
highest precedence of all arithmetic operators.



\subsection{Concatenation and Reversal}


A standard definition of list concatenation looks like

\begin{alba}
  (+) A (a b: List A): List A :=
    inspect a case
      [] :=
        b
      h ^ t :=
        h ^ (t + b)
\end{alba}
Note that the operator $+$ is left associative.


List concatenation is associative
%
\begin{alba}
  sum_associates A (a b c: List A): a + b + c = a + (b + c) :=
    inspect a case
      h ^ t :=
        goal where
          goal: h ^ t + b + c = h ^ t + (b + c) :=
            via
               h ^ t + b + c
               h ^ (t + b + c)      -- def (+)
               h ^ (t + (b + c))    -- hypo
               h ^ t + (b + c)      -- def (+)
          hypo: t + b + c = t + (b + c) :=
            sum_associates t b c
\end{alba}


\begin{alba}
  nil_right_neutral A (a: List A): a + [] = a :=
    inspect a case
      h ^ t :=
        goal where
          goal: h ^ t + [] = h ^ t :=
            via
              h ^ t + []
              h ^ (t + [])   -- def (+)
              h ^ t          -- hypo
          hypo: t + [] = t :=
            nil_right_neutral t
\end{alba}


A simple function to reverse a list looks like

\begin{alba}
  reverse A (a: List A): List A :=
    inspect a case
      [] :=
        []
      h ^ t :=
        reverse t + [h]
\end{alba}



\begin{alba}
  reversal_of_concatenation
    A
    (a b: List A)
    : reverse (a + b) = reverse b + reverse a :=
      inspect a case
        [] :=
          goal where
            goal: reverse ([] + b) = reverse b + reverse [] :=
              via reverse b
                  reverse (b + [])

        h ^ t :=
          goal where
             goal: reverse (h ^ t + b) = reverse b + reverse (h ^ t) :=
               via
                 reverse (h ^ (t + b))                      -- def '+'
                 reverse (h ^ (reverse b + reverse t))      -- hypo
                 (reverse b + reverse t) + [h]              -- def 'reverse'
                 reverse b + (reverse t + [h])              -- '+' assoc
                 reverse b + reverse (h ^ t)                -- def 'reverse'

             hypo: reverse (t + b) = reverse b + reverse t :=
               reversal_of_concatenation t b
\end{alba}


\begin{alba}
  reverse_prepend A (a b: List A): List A :=
      -- prepend the reversal of 'a' in front of 'b'
    inspect
      a
    case
      [] :=
        b
      h ^ t :=
        t.reverse_prepend (h ^ b)
\end{alba}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main_alba_design"
%%% End:
