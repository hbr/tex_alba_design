
\chapter{Certified Programming}
\label{chap:certprog}





\newpage
\section{Logic}
\label{sec:certprog-logic}


\subsection{Negation}

Negation is defined in the prelude as
\begin{alba}
  (not) (a: Proposition): Proposition :=
    a => false
\end{alba}

We want to prove the contrapositive law of logic which states
\begin{alba}
  (a => b) => not b => not a
\end{alba}
for all propositions \code{a} and \code{b}. A proof of that fact would be
written in Alba as the function
%
\begin{alba}
  contrapositive a b (ab: a => b) (nb:not b): not a :=
    ...
\end{alba}
%
It is not necessary to write such a proof by hand, because the compiler can
generate such a proof automatically. Here we explain what the compiler does.

First it expands the goal
\begin{alba}
  not a   =  (a => false)
\end{alba}
I.e. we need a function mapping a proof of \code{a} into a proof of
\code{false}. We have already an argument \code{nb} mapping a proof of
\code{b} into a proof of \code{false} and an argument \code{ab} mapping a
proof of \code{a} into a proof of \code{b}. A proof of false is just a
composition of both functions like
%
\begin{alba}
  \ (pa: a): false := nb (ab pa)
\end{alba}
%
But since proof arguments are implicit in Alba we have no possibility to write
these arguments explicitly. The best we can do to make the steps explicit is
to write the function as
%
\begin{alba}
  contrapositive a b (ab: a => b) (nb:not b): not a :=
    \ (pa: a): false :=
      nb               -- implicit argument pb
      where
        pb: b := ab    -- implicit argument pa
\end{alba}
%




\subsection{Disjunction}

Logical dijunction is defined in the prelude as the inductive type
%
\begin{alba}
  class
    (or) (a b: Proposition): Proposition
  create
    left:  a => a or b
    right: b => a or b
\end{alba}


\begin{alba}
  swap_or a b (p:a or b): b or a :=
    inspect
      p
    case
      left  := right
      right := left
\end{alba}

\begin{alba}
  eliminate_or a b c (ab: a or b) (ac: a => c) (bc: b => c): c :=
    inspect
      ab
    case
      left :=
        ac
      right :=
        bc
\end{alba}


\subsection{Conjunction}

\begin{alba}
  class
    (and) (a b: Proposition): Proposition
  create
    conjunction: a => b => a and b
\end{alba}


\begin{alba}
  swap_and (a b: Proposition) (p:a and b): b and a :=
    inspect
      p
    case
      conjunction := conjunction
\end{alba}


\begin{alba}
  eliminate1_and (a b: Propositon) (p: a and b): a :=
    inpect p case
      conjunction := _
\end{alba}







\newpage
\section{Relations}
\label{sec:certprog-relations}


\subsection{Basic Properties}


In the following we consider endorelations i.e. binary relations where both
domains are the same. For endorelations we can define what it means to be
reflexive, transitive and symmetric.

\begin{alba}
  is_reflexive (A:Any) (r: Endorelation A): Proposition :=
    all a: r a a

  is_transitive (A:Any) (r: Endorelation A): Proposition :=
    all a b c: r a b => r b c => r a c

  is_symmetric (A:Any) (r: Endorelation A): Proposition :=
    all a b: r a b => r b a
\end{alba}


Next we define the transitive closure of a relation.

\begin{alba}
  class
    plus (A:Any) (r: Endorelation A): Endorelation A
      -- 'plus r' is the transitive closure of 'r'
  create
    init a b:
      r a b
      => plus r a b
    step a b c:
      r a b
      => plus r b c
      => plus r a c
\end{alba}

The definition uses an inductive type. It uses two constructors. The
\code{init} constructor allows us to conclude \code{plus r a b} from \code{r a
  b}.
The \code{step} constructor allows us to conclude \code{plus r a c} from
\code{r a b} and \code{plus r b c}.

By intuition we see that the relation \code{plus r} is transitive. But in
order to be sure we need a proof. In order to proof transitivity we have to
prove
%
\begin{alba}
  plus r a b => plus r b c => plus a c
\end{alba}
%
i.e. we need a function which looks like
%
\begin{alba}
  f a b c (pab: plus r a b) (pbc: plus r b c): plus r a c :=
    ...
\end{alba}
%
In order to this we can do an induction proof on \code{pab: plus r a b} which
generates two cases.

One case is that \code{plus r a b} has been constructed
by \code{init a b rab}. In that case we can use the step constructor with
\code{ab: r a b} and \code{pbc: plus r b c} to construct \code{plus r a c}.

The second case is that  \code{plus r a b} has been constructed by \code{step
  a x b (ax: r a x) (pxb: plus r x b)}. Now we can use the induction
hypothesis to construct from \code{pxb} and \code{pbc} a proof of \code{plus r
  x c} and then the step constructor to generate a proof of \code{plus r a c}.


\begin{alba}
  plus_transitive A (r:Endorelation A): (plus r).is_transitive :=
    f a b c (pab: plus r a b) (pbc: plus r b c): plus r a c :=
      inspect
        pab
      case
        init a b (ab: r a b) :=
            -- a -> b +> c
          step a b c ab pbc

        step a x b (ax: r a x) (pxb: plus r x b) :=
            {: a -> x +> b +> c
               by a recursive call to f we prove x +> c
               and then use the step constructor to prove a +> c :}
          step a x c ax (f x b c pxb q: plus r x c)
\end{alba}

This is a very detailed proof where Alba's builtin proof engine has nothing to
do. All steps are given explicitly. The proof is not difficult. But it is
tedious to get all the arguments right.

The compiler can save  a lot of tedious work for us.

First we see that the proof in the \code{init} case is trivial. The compiler
sees the goal \code{plus r a c}, sees that the step function can generate such
a goal by \code{step a x c (\_:r a x) (\_:plus r x c)} and both placeholders
can be filled from the context. I.e. no hint to the compiler is necessary.

In the second case the compiler can try the step function as well. The term
\code{ax: r a x} from the pattern match allows to instantiate the intermediate
variable \code{x} and an application of the induction hypothesis does the
rest.

Therefore a minimalistic proof which uses the proof engine full looks like
%
\begin{alba}
  plus_transitive A (r:Endorelation A): (plus r).is_transitive :=
    f a b c (pab: plus r a b) (pbc: plus r b c): plus r a c :=
      inspect
        pab
\end{alba}
%
However such a condensed code gives no information to the user on how to do
the proof. An intermediate version might be
%
\begin{alba}
  plus_transitive A (r:Endorelation A): (plus r).is_transitive :=
    f a b c (pab: plus r a b) (pbc: plus r b c): plus r a c :=
      inspect
        pab
      case
        init a b _ :=
            -- a -> b +> c
          step a b c _ _

        step a x b _ _ :=
            {: a -> x +> b +> c
               by the induction hypothesis we can prove x +> c
               and then use the step constructor to prove a +> c :}
          step a x c _ (f x b c _ _)
\end{alba}
%
This proof leaves out all the details for finding the low level proofs (which
is just mechanical work) but give the reader of the code the proof idea.



\paragraph{Discussion} What if we make proof arguments always implicit. Up to
now the strategy has been that proof arguments are implicit in normal
functions and explicit in proof functions.

\begin{alba}
  plus_transitive A (r:Endorelation A): (plus r).is_transitive :=
    f a b c (pab: plus r a b) (pbc: plus r b c): plus r a c :=
      inspect
        pab
      case
        init a b :=
          step a b c

        step a x b :=
          step a x c
            where
              _: plus r x c :=  f x b c
\end{alba}
%
This seems to convey very good the proof idea without a lot of
clutter. Furthermore the number of arguments have been reduced drastically and
the comments are no more necessary, because the code speaks for itself.

The \code{where} clause is not strictly necessary, it just indicates that an
induction hypothesis is generated by a call to \code{f}. However it is clear
that the proof is an induction proof, because a name \code{f} has been
introduced (which is necessary only for recursive functions) and a pattern
match has been used which surfaces subproofs which can be used in \code{f} to
generate induction hypotheses.



In the same manner as the transitive closure we can define the reflexive
transitive closure of a relation.

\begin{alba}
  class
    star (A:Any) (r: Endorelation A): Endorelation A
      -- 'star r' is the reflexive transitive closure of 'r'
  create
    init a:
      star r a a

    step a b c:
      r a b
      => star r b c
      => star r a c
\end{alba}

Having the definition we prove that the reflexive transitive closure is
transitive.

\begin{alba}
  star_transitive A (r:Endorelation A): (plus r).is_transitive :=
    f a b c (sab: star r a b) (sbc: star r b c): star r a c :=
      inspect
        sab
      case
        init a :=
          sbc
            -- a = b in this case

        step a x b :=
          step a x c
            -- using induction hypo: f x b c: star r x c
\end{alba}


\subsection{Diamonds and Confluence}


A relation is a diamond if it is always possible to join two steps with a
single step.

\begin{alba}
  is_diamond A (r: Endorelation A): Proposition :=
      {:   a  ->  b
           |      |
           v      v
           c  -> some d :}
    all a b c:
      r a b
      => r a c
      => some d: r b d and r c d
\end{alba}


A relation is confluent if its reflexive transitive closure is a diamond.

\begin{alba}
  is_confluent A (r: Endorelation A): Proposition :=
    (star r).is_diamond
\end{alba}







\subsection{Draft Material}


\begin{alba}
  is_diamond (A:Any) (r: Endorelation A): Proposition :=
    all a b c: r a b => r a c => some d: r b d and r c d

  class
    plus (A:Any) (r: Endorelation A): Endorelation A
      -- 'plus r' is the transitive closure of 'r'
  create
    init a b: r a b => plus r a b
    step a b c: r a b => plus r b c => plus r a c

  class
    star (A:Any) (r: Endorelation A): Endorelation A
      -- 'star r' is the reflexive transitive closure of 'r'
  create
    init a: star r a a
    step a b c: r a b => star r b c => star r a c
\end{alba}







\begin{alba}
  plus_transitive A (r:Endorelation A): (plus r).is_transitive :=
    f a b c (p: plus r a b) (q: plus b c): plus r a c :=
      inspect
        p
      case
        init a b (pr: r a b) :=
            -- a -> b +> c
          step a b c pr q
        step a x b (pax: r a x) (pxb: plus r x b) :=
            {: a -> x +> b +> c
               by a recursive call to f we prove x +> c
               and then use the step constructor to prove a +> c :}
          step a x c pax (f x b c pxb q: plus r x c)
\end{alba}











\newpage
\section{Lists}
\label{sec:certprog-lists}


In the following we use the definition of the list type from the prelude.

\begin{alba}
  class
    List (A:Any): Any
  create
    [] : List A
    (^): A -> List A -> List A
\end{alba}
%
Note that the operator $\caret$ is right associative and has the
highest precedence of all arithmetic operators.



\subsection{Concatenation and Reversal}


A standard definition of list concatenation looks like

\begin{alba}
  (+) A (a b: List A): List A :=
    inspect a case
      [] :=
        b
      h ^ t :=
        h ^ (t + b)
\end{alba}
Note that the operator $+$ is left associative.


List concatenation is associative
%
\begin{alba}
  sum_associates A (a b c: List A): a + b + c = a + (b + c) :=
    inspect a case
      h ^ t :=
        goal where
          goal: h ^ t + b + c = h ^ t + (b + c) :=
            via
               h ^ t + b + c
               h ^ (t + b + c)      -- def (+)
               h ^ (t + (b + c))    -- hypo
               h ^ t + (b + c)      -- def (+)
          hypo: t + b + c = t + (b + c) :=
            sum_associates t b c
\end{alba}


\begin{alba}
  nil_right_neutral A (a: List A): a + [] = a :=
    inspect a case
      h ^ t :=
        goal where
          goal: h ^ t + [] = h ^ t :=
            via
              h ^ t + []
              h ^ (t + [])   -- def (+)
              h ^t           -- hypo
          hypo: t + [] = t :=
            nil_right_neutral t
\end{alba}

\vskip 10mm
\noindent STATUS: VERY DRAFT


\begin{alba}
  class
    List (A:Any): Any
  create
    []: List A
    (::): A -> List A -> List A

  class
    is_sum A: List A -> List A -> List A -> Proposition
      -- s.is_sum a b means 's' ist the concatenation of 'a' and 'b'.
  create
    init a:
      a.is_sum [] a
    step e s a b:
      s.is_sum a b
      =>
      (e :: s).is_sum (e :: a) b
\end{alba}




\begin{alba}
  sum_nil (s a: List A) (p: s.is_sum [] a): s = a :=
    inspect
      p
    case
      init a :=
        _    -- s = a in that case
      step e xy x y: (e :: xy).is_sum (e :: x) y :=
          -- [] = e :: x is a contradiction
        _
\end{alba}



\begin{alba}
  sum_unique (a b s1: List A) (p: s1.is_sum a b)
    : all s2: s2.is_sum a b => s1 = s2 :=
    inspect
      p
    case
      init b :=
        --  a = []
      step ???? :=
        ????
\end{alba}

\begin{alba}
  sum_associates
   (a b c ab bc ab_c a_bc: List A)
   : ab.is_sum a b
     => bc.is_sum
     => ab_c.is_sum ab c
     => a_bc.is_sum a bc
     => ab_c = a_bc  :=
     inspect
       a
     case
       [] :=
         ???
       h :: t :=
         ???
\end{alba}




\begin{alba}
  class
    is_reverse A: Endorelation (List A)
      -- a.is_reverse b means 'a' is 'b' reversed
  create
    init:
      [].is_reverse []
    step ra a s e:
      ra.is_reverse a
      => s.is_sum ra [e]
      => s.is_reverse e :: a
\end{alba}

\begin{alba}
  reverse_prepend A (a b: List A): List A :=
      -- prepend the reversal of 'a' in front of 'b'
    inspect
      a
    case
      [] :=
        b
      hd :: tl :=
        tl.reverse_prepend e :: b
\end{alba}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main_alba_design"
%%% End:
