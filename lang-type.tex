\section{Intermediate Language}
\label{sec:lang-intermediate-language}

In this chapter the intermedicate language of the Alba compiler is defined. It
is a typed lambda calculus with inductive types.

The compiler transforms the Alba source code into the typed intermediate
language.

As opposed to untyped lambda calculus all bound variables have types i.e. the
calculus is Church style.

Notational conventions:
\begin{enumerate}
\item The types of bound variables are written as exponents. The term
  $\lambda x^A. e$ is a function term mapping any term $a$ of type $A$ to the
  term $e[x:=a]$.

\item As usual in lambda calculi, function application is written by
  juxtaposition. The term $f\,a$ is the application of the function $f$ to the
  argument $a$. We can apply a function to many arguments by $f \, a \, b \,
  \ldots$.

\item Function application associates to the left $f a b = (f a) b$.

\item Multiple arguments in function terms $\lambda x^A. \lambda y^B . e$,
  which is parsed as $\lambda x^A. (\lambda y^B . e)$, can be abbreviated by
  $\lambda x^A y^B. e$.

\item We use boldface to express arrays of terms. The expression $\abold$ must
  be read as $[a_0, a_1, \ldots]$ and $|\abold|$ is the size of the array.

\item The term $f \, \abold$ must be read as $f \, a_0 \, a_1 \, \ldots$.

\item We use boldface to abreviate $\lambda x_0^{A_0} x_1^{A_1} \ldots . e$ by
  $\lambda \xbold^\Abold. e$ and $[x_0^{T_0}, x_1^{T_1}, \ldots]$ by
  $[\xbold^\Tbold]$
\end{enumerate}







\subsection{Terms}
\label{sec:terms}


The type system of Alba is based on dependent types with inductive
constructions. There is no syntactic difference between sorts, terms and
types. Everthing is a term and every valid term has a type. The type of a term
is a term as well and not necessarily a type (it can be a sort or a
kind). This ambiguous wording of a type and a type of a term is often a source
of confusion. However without inventing a completely new terminology this
ambiguity is unavoidable.


In this paper we use the wording that
\begin{itemize}
\item a term is an object, if its type is a type,
\item a term is a type, if its type is a sort
\item a term is a type constructor if its type is a kind (sort valued
  function) {\small Note: Since sorts are kinds a type is a type constructor
    with no arguments}
\item otherwise a term is kind.
\end{itemize}
The wording becomes clearer after the introduction of formal typing
rules~\ref{sec:typing-rules}. In order to understand terms, the intuitive
definition might be sufficient.

\begin{definition}
  There are 4 sorts in Alba
  \begin{enumerate}

  \item $\Prop$: The type of propositions. In Alba we use the Curry-Howard
    correspondence with propositions as types. The proposition $i > 0$ is a
    type whose type is the sort $\Prop$. I.e. we have the typing judgement $i
    > 0 : \Prop$. A term $p$ of type $i > 0$ (i.e. $p:i > 0$) is a proof of $i
    > 0$. Sometimes we use the notation $p : i > 0 : \Prop$ to express the two
    typing judgements with one expression. In program text $\Prop$ is written as
    \code{Proposition}.


  \item $\Any$: The type (or maybe better the sort) of all types. $\Any$ is
    the type of numbers, strings, characters is $\Any$ i.e. we have the typing
    judgements \code{Natural} : $\Any$, \code{String} : $\Any$,
    \code{Character} : $\Any$, etc. In program text $\Any$ is written as
    \code{Any}.


  \item $\Box$: The supertype of all types (or sorts). We have the
    valid typing judgements $\Prop: \Any$, $\Any : \Box$ and because of
    transitivity $\Prop: \Box$.


  \item Abstract datatypes: In Alba abstract datatypes are not types, they are
    sorts. E.g. \code{Sortable} is an abstract datatype i.e. a sort in
    Alba. The typing judgement \code{Natural}: \code{Sortable} is valid,
    because the natural numbers have a decidable linear order i.e. they have
    an order relation $\le$ and a decision function which given two numbers
    $a, b$ either returns a proof of $a \le b$ or $\lnot\, a \le b$.

    For all abstract datatypes $A$ the typing judgement $A: \Any$ is
    valid. We can view $\Any$ as an abstract datatype which imposes no
    requirements in its subtypes. Therefore any sort $S$ different from $\Any$
    satisfies the judgment $S: \Any$.
  \end{enumerate}
\end{definition}


Remarks:
\begin{enumerate}
\item The status of abstract datatypes is still draft. You can ignore them and
  read the following with $\Any$, $\Prop$ and $\Box$ as the only sorts.

\item It might be necessary to introduce an infinite sort hierachy
  $\Any_0, \Any_1 \ldots$ where $\Any_0$ corresponds to $\Any$ and we have the
  typing judgement $\Any_i : \Any_{i+1}$. The above description corresponds to
  a cut of the sort hierarchy at $\Any_1$ where $\Any_1$ corresponds to
  $\Box$. If we introduce the infinite type hierarchy, then the type system
  without inductive types corresponds to the extented calculus of
  constructions (ECC~\cite{luo1990}).

\item If we remove the sort $\Box$ i.e. cut the type hierarchy at $\Any$ and
  remove inductive constructions, then the calculus is the same as the
  calculus of constructions (sometimes abbreviated as CC or CoC).
\end{enumerate}



The set of all sorts has an order relation relation $\prec$ which must be free
of cycles. Without considering abstract datatypes the order is
$$
\Prop \prec \Any \prec \Box
$$
or
$$
\Prop \prec \Any_0 \prec \Any_1 \prec \ldots
$$
in the case of an infinite type hierachy.




%%% Context %%%%
\begin{definition}
  A \emph{context} $\Gamma$ is a list of variable/type pairs
  $$
  \Gamma = [x_0^{T_0}, x_1^{T_1}, x_2^{T_2}, \ldots]
  $$
  where the variables are unique (no duplicates) and the type $T_i$ might
  contain the variables $x_0, \ldots, x_{i-1}$. Because of the last condition
  a context is not a set of variable/type pairs, but a list. Swapping
  variable/type pairs might invalidate this condition.

  We write $\Gamma, x:T$ for the context $\Gamma$ with one more variable $x$
  of type $T$.

  Note that a context is just a list of variables with their corresponding
  types. Therefore we can use a context in any binder (abstraction, dependent
  product, etc.) e.g.
  $$
  \lambda x_0^{T_0} x_1^{T_1} \ldots \, e
  $$
  can be abbreviated by
  $$
  \lambda \Gamma . e
  $$
  where $\Gamma = [x_0^{T_0}, x_1^{T_1}, \ldots]$
\end{definition}








\begin{definition}
  Let $i,k$ range over numbers, $s$ range over sorts, $x,y$ range over
  variables, $t, a, e, f, A, B, C, T, R$ range over terms and $\Gamma$ range
  over contexts. We use boldface to indicate a list of something. Terms are
  defined by the grammar
  $$
  \begin{array}{lllll}
    t &:= & s
    & \text{sort}

    \\

      & \mid & x
    & \text{variable}

    \\

      & \mid & f \, a
    & \text{application}

    \\

      & \mid & \lambda x^A. e
    & \text{abstraction}

    \\

      & \mid & \Pi x^A.B
    & \text{dependent product}

    \\

      & \mid & \Inductive_{\Gamma,x^T,\Cbold}
    & \text{inductive type}

    \\

      & \mid & \Constructor^i_T
    & \text{i-th constructor of the inductive type } T

    \\

      & \mid & \case(e, \lambda \ybold^\Abold x^T.R, \fbold)
    & \text{pattern match}

    \\

      & \mid & \fix(x^T, t, k)
    & \text{fixpoint}
  \end{array}
  $$
\end{definition}

The terms $x$, $f a$, $\lambda x^A.e$ are already known from untyped lambda
calculus except that in untyped lamda calculus the bound variable $x$ in the
abstraction does not have a type and in our typed calculus the it has the type
$A$. The terms for products, inductive types, constructors, pattern match and
fixpoints (recursive function) need some explanation.

\begin{description}
\item[Dependent product] $\Pi x^A.B$ In simply typed lambda calculus
  $A \to B$ is the type of a functions from objects of type $A$ to objects of
  type $B$. But since we have dependent types, a variable of type $A$ might
  occur in $B$, therefore we need a binder. $\Pi x^A. B$ is the type of a
  function which maps an object $a$ of type $A$ to an object of type
  $B[x:=a]$. It is easy to see that $A \to B$ is just an abbreviation for
  $\Pi x^A.B$ where $x$ does not occur in $B$.

  With dependent types, a type can depend on a variable which is not a
  type. If the variable $i$ is of type $\mathbb{N}$, then the term $i > 0$ is
  a type which represents a proposition (i.e. $i > 0: \Prop$ is valid).

  The term $\Pi i^{\mathbb{N}}. i > 0$ is the type of a function which maps
  any natural number $n$ to a proof of $n > 0$. Obviously such a function
  cannot exist because it would map the number $0$ into a proof of $0 > 0$
  which implies a contradiction. In type theory we say that the type
  $\Pi i^{\mathbb{N}}. i > 0$ is not inhabited. A function of type
  $\Pi i^{\mathbb{N}}. i \ge 0$ can exist, because it maps any natural number
  $n$ into a proof of the trivial fact $n \ge 0$.

\item[Inductive type] $\Inductive_{\Gamma,x^T,\Cbold}$ An inductive type
  consists of a context of parameters
  $\Gamma = [p_0^{P_0}, p_1^{P_1}, \ldots]$, a type $T$ which is valid in a
  context with the parameters and a variable of this type and an array of
  constructor types $\Cbold = [C_0, C_1, \ldots]$ which are all valid in the
  context $\Gamma, x^T$ appended to the global context.

  The parameter types $P_i$ are usually $\Any$ so that the parameter variables
  $p_i$ are type variables. The inductive type of natural numbers has no
  parameters, the inductive type of list has one parameter (therefore it makes
  sense to talk about a list of elements of type $A$).

  Two examples to illustrate the definition:
  $$
  %
  \begin{array}{lllll}
    \mathbb{N}
    &:=& \Inductive_{[], I^\Any, [I, I \to I]}
    &:& \Any
    \\
    \mathbb{L}
    &:=& \Inductive_{[A^\Any],  I^{\Any\to\Any},  [IA, A \to IA \to IA]}
    &:& \Any \to \Any
  \end{array}
  $$
  The type of natural numbers needs two constructors, a constant zero and a
  successor function.

  The type of list has one type parameter and two constructors. One to
  construct the empty list, and one which prepends an element in front of an
  existing list. Note that the variable $I$ in the list definition already
  represents a list of $A$.

  Since $\mathbb{N}$ has no parameters, its type is the same as the type of
  its bound variable $I$ i.e. it is the sort $\Any$.

  Since $\mathbb{L}$ has one parameter, its type is a function of the
  parameter type to the type of its bound variable i.e. its type is the kind
  $\Any \to \Any$ (sort valued function type). The term $\mathbb{L}$ is not a
  type, it is a type constructor which needs one argument to generate an
  actual type. The term $\mathbb{L} \, \mathbb{N}$ represents the type of
  lists of natural numbers.

  In program text we write
  \begin{alba}
      class Natural: Any
      :=
            0: Natural
            succ: Natural -> Natural

      class List (A:Any): Any :=
            []: List A
            (+:): A -> List A -> List A
  \end{alba}
  to express the type of natural numbers and the type of lists.

  Note that in the mathematical definition of an inductive type the name of
  the bound variable $I$ is completely arbitrary and the constructors don't
  need names, just the types are needed. Names are for humans, therefore in
  the program text we use the names for the inductive types and the
  constructors. In the mathematical formulae the term
  $\Inductive_{[], I^\Any, [I, I \to I]}$ completely specifies the type and
  $\mathbb{N}$ is just a name for it.

  Furthermore note that the type constructor $T$ in $\Inductive_{\Gamma, x^T,
  \Cbold}$ might have the form $\Pi \pbold^\Pbold \ybold^\Abold. \ldots$ i.e. in
  order to build a type term other arguments beside the parameters might be
  needed.  Therefore in general an inductive type (and not only a type
  constructor) has the form $$ \Inductive_{\Gamma, x^T, \Cbold} \; \pbold \;
  \abold $$ where $\pbold$ is the array of parameters and $\abold$ is the arrary
  of other arguments. The arguments beside the parameters of an inductive type
  are sometimes called the index or the indices of the inductive type.


\item[Constructor] $\Constructor^i_T$ This term specifies the $i$-th
  constructor of the inductive type $T$. It is the actual constructor object
  and not the constructor type. The following typing judgements are valid.
  $$
  %
  \begin{array}{lll}
    \Constructor^0_\mathbb{N}
    &:& \mathbb{N}
    \\
    \Constructor^1_\mathbb{N}
    &:& \mathbb{N} \to \mathbb{N}
    \\
    \Constructor^0_\mathbb{L}
    &:& \Pi A^\Any. \mathbb{L} \, A
    \\
    \Constructor^1_\mathbb{L}
    &:& \Pi A^\Any. A \to \mathbb{L}\, A -> \mathbb{L}\,A
  \end{array}
  $$
  %
  The term $\Constructor^0_{\mathbb{N}}$ represents the number $0$ and
  therefore has the type $\mathbb{N}$. The term $\Constructor^1_{\mathbb{N}}$
  represents the successor function and therefore has type
  $\mathbb{N}\to\mathbb{N}$.

  The parameters of an inductive type are arguments for the constructors and
  have to be provided to get an object of the inductive type. Usually the
  parameters occur within the constructor types (otherwise they would be
  meaningless) and therefore e.g. the type of $\Constructor^0_{\mathbb{L}}$ is
  a dependent product. In order construct an empty list of natural numbers we
  need the term
  $$
  %
  \Constructor^0_{\mathbb{L}} \, \mathbb{N}
  $$
  and the term
  $$
  \Constructor^1_{\mathbb{L}}
  \,
  \mathbb{N}
  \,
  \underbrace{\Constructor^0_{\mathbb{N}}}_{\text{zero}}
  \,
  (\underbrace{\Constructor^0_{\mathbb{L}} \, \mathbb{N}}_{\text{empty list}})
  $$
  constructs a singleton list of natural numbers with the element zero.


\item[Pattern match]
    $\case(\fbold, \lambda \ybold^\Abold x^T. R)$

    A pattern match expression of this form has the type $\Pi \ybold^\Abold
    x^T.R$ where $\Abold$ are the types of the indices of the inductive type and
    $T = \Inductive_{\ldots} \pbold \ybold$ is the inductive type containing
    arbitrary parameters $\pbold$ and the indices $\ybold$.  I.e. a case
    expression expects one argument for each index and one argument for an
    object of the inductive type. $R$ is the result type of the case expression
    applied to its arguments. The result type might depend on the indices and on
    the inductive object.

    The inductive type $\Inductive_{\ldots} \pbold \abold$ must be a type and
    not only a type constructor i.e. it must have enough arguments to be a type.
    E.g. $\mathbb{N}$ and $\mathbb{L}\, \mathbb{N}$ are types, but $\mathbb{L}$
    is not a type (only a type constructor).

    The subterm $\lambda \ybold^\Abold x^T.R$ is the elimination function. It
    determines the result type of the pattern match expression. It is a function
    which maps the index expressions $\abold$ and an expression $e$ of type
    $\Inductive_{\ldots} \pbold \abold$ to $R[\ybold := \abold, x:=e]$
    which is the result type of the expression. In many simple cases $R$ does
    not depend on its arguments and therefore the result type is the same for
    all cases of the pattern match. However the elimination function becomes
    important as soon as each case returns an object of a different type.

    The array $\fbold = [f_0, f_1, \ldots]$ contains a function for each
    constructor of the inductive type. The function $f_i$ maps the arguments of
    the $i$-th constructor to an object of the corresponding result type of the
    case.

    The following two functions are used to illustrate a pattern match term.
    {\def\Nat{\mathbb{N}}
      $$
      %
      \begin{array}{l}
          \case ([ 0 , \lambda i^\Nat. 1], \lambda \_^\Nat. \Nat)

          \\

          \case ([ 0, \lambda i^\Nat. i], \lambda \_^\Nat. \Nat)
      \end{array}
      $$
      where $0$ is an abbreviation for $\Constructor^0_\Nat$ and $1$ is an
      abbreviation for $\Constructor^1_\Nat\, \Constructor^0_\Nat$
      (i.e. successor of zero).
    }

    The first function maps the number zero to the number zero and every other
    number to the number one. The second one computes a predecessor function
    which maps the number zero to zero and every other number to its
    predecessor. Since every number different from zero is constructed by
    applying the second constructor to its predecessor, the needed function in
    the case expression is just the identity function.

    Note that the elimination function is trivial in both examples because a
    natural number is returned in each case of the pattern match.

    {\def\Nat{\mathbb{N}} \def\List{\mathbb{L}}

        In the calculus some weird function can be defined. E.g.
        $$
        F :=
        \case(
            [\Nat,\, \lambda i^\Nat. \List\, \Nat],\;
            \lambda \_^\Nat. \Any
        )
        $$
        defines a function which maps the number zero to the type of natural numbers
        and every other number to the type of list of natural numbers. Therefore the
        $F$ is a type valued function whose argument is a number i.e. an
        object.

        We can use the function $F$ as an elimination function to define a
        function which maps the number zero to the number zero and every other
        number to an empty list of natural numbers.
        $$
        \case([\Constructor^0_\Nat,\, \Constructor^0_\List\, \Nat],\; F)
        $$
    }


\item[Fixpoint] $\fix(x^T, t, k)$ A Fixpoint encodes a recursive function. It
  consists of a bound variable $x$ and its type $T$, a term $t$ using this
  bound variable an a number $k$ indicating that the $k$-th argument of the
  function is decreasing. The fixpoint and the bound variable have the same
  type
  $$
  \begin{array}{lll}
    x &:& T
    \\
    \fix(x^T, t, k) &:& T
  \end{array}
  $$
  i.e. $T$ must be a function type $\Pi x^A y^B \ldots . R$ with at least $k$
  arguments. Because the bound variable and the fixpoint have the same type,
  it is possible to replace the bound variable $x$ in $t$ with the fixpoint
  $t[x := \fix(x^T, t, k)]$. In order to avoid infinite recursion, some
  argument must be decreased on each substitution (see chapter
  \ref{sec:reduction}~Reduction and \ref{sec:typing-rules}~Typing Rules).

  { \def\Nat{\mathbb{N}}

    As an example for a fixpoint aka recursive function we use the function
    which given a number $n$, a start value $a$ and an iteration function $g$
    computes the $n$-th iteration of $g$ with the start $a$ i.e. $g^n a$. The
    start value can be of any type $A$ and correspondingly the iteration
    function must have type $A \to A$. The type $T$ of the recursive function
    is $\Pi A^\Any. \Nat \to A \to (A \to A) \to A$. The recursive function is
    defined by the fixpoint term
    $$
    \fix (
    f^T,
    \lambda A n a g.
      \case(n,
            \lambda n^\Nat. A,
            [a, \lambda i. g (f A i a g)]
      ),
      1)
    $$
  }%
  Note that we ommitted the type annotations in the inner function term
  because the types are clear by looking at $T$.

  In program text we write the recursive function as
  \begin{alba}
    fold: all(A:Any): Natural -> A -> (A -> A) -> A
    fold A n a g :=
       inspect n case
          0 := a
          succ i := g (fold A i a g)
  \end{alba}
\end{description}






\subsection{Reduction}
\label{sec:reduction}

\begin{definition}
  The reduction relation $a \reduce b$ is defined as the compatible closure of
  the relation defined by the following rules
  \begin{enumerate}

  \item Beta reduction
    $$
    (\lambda x^A.e)\,a \reduce e[x:=a]
    $$

  \item Pattern match
    $$
    \rulev
    {
        T \text{ is an inductive type}
        \\
        |\fbold| \text{ number of constructors}
        \\
        j < |\fbold|
        \\
        |\abold| \text{ number of indices}
        \\
        |\pbold| \text{ number of parameters}
        \\
        |\bbold| \text{ number of arguments of constructor } j
    }
    {
        \case(\fbold, \_)\, \abold \, (\Constructor^j_T \pbold \bbold)
        \reduce
        f_j \, \bbold
    }
    $$


  \item Fixpoint
    $$
    \ruleh
    {|\abold| = k}
    {
      \fix(x^T, t, k) \,
      \abold \,
      (\Constructor^i_{\Inductive_{\Gamma,y:U,\Cbold}} \, \bbold)
      \reduce
      t[x := \fix(x^T, t, k)] \,
      \abold \,
      (\Constructor^i_{\Inductive_{\Gamma,y:U,\Cbold}} \, \bbold)
    }
    $$
  \end{enumerate}
  Compatible closure means that a term can be reduced by reducing one of its
  subterms.
\end{definition}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Inductive Types}
\label{sec:inductive-types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


In this chapter we explain more in detail the inductive types. It is worth
noting that the calculus does not gain expressive power by inductive
types. All functions which can be defined with inductive types can be defined
without inductive types by using church encoding (e.g. church numerals) to
encoded inductive objects. However inductive types allow for more efficient
runtime evaluation of functions and are closer to intuition.


\subsubsection{Kinds}

\begin{definition}
  A \emph{kind} is either a sort or a sort valued function. Let $k$ range
  over kinds, $A$ over terms and $s$ over sorts. Kinds are defined by the
  grammar
  $$
  \begin{array}{lll}
    k
    &:=& s
    \\
    &\mid& \Pi x^A. k
  \end{array}
  $$
  i.e. a term of the form
  $$
  \Pi x^A y^B \ldots . s
  $$
  where $s$ is a sort is a kind and $x, y, \ldots$ are the arguments of the
  kind and $A, B \ldots$ are the argument types of the kind. Clearly a kind
  might have no arguments.

  We are sometimes sloppy in our wording and say that a term is a kind if it
  reduces to a kind. But since kinds are defined by syntax this is not 100\%
  correct.

  The final type of a kind is always a sort and it is \emph{the} sort of the
  kind. Therefore it makes sense to talk about the sort of a kind. The
  argument types might be sorts (or even kinds) as well, but this is not
  relevant.
\end{definition}



\subsubsection{Inductive Type}

Now recall the definition of a term describing an inductive type
$$
\Inductive_{\Gamma, \; I:T, \; \Cbold}
$$
where $\Gamma = [p_0:P_0, p_1: P_1, \ldots]$ are the parameters of the
inductive type and $\Cbold = [C_0, C_1, \ldots]$ its constructor types.

In order to define an inductive type, the type $T$ of the bound variable $I$
must reduce to a kind i.e. $T \reduce^* \Pi \pbold^\Pbold \xbold^\Abold. s$. The
arguments $\xbold$ of $T$ are the arguments of the inductive type. In the
literature the arguments of an inductive type are called the index or indices of
the inductive type in order distinguish them clearly from the parameters.





\subsubsection{Constructor}

\begin{definition}
  The \emph{type of a constructor} for the bound variable $I$ is defined by
  the grammar
  $$
  \begin{array}{lll}
    C
    &:= & I \pbold \abold
    \\
    &\mid& \Pi x^A . C
  \end{array}
  $$
  where $C$ ranges over type of constructors, $\pbold$ are the parameters and
  $\abold$ is an array of terms. I.e. the type of a constructor for the bound
  variable $I$ has the form $\Pi \xbold^\Abold. I \pbold  \abold$ where
  $|\abold|$ corresponds to the number of arguments (indices) of the inductive
  type.
\end{definition}

All constructor types of an inductive definition must reduce to a type of a
constructor for the corresponding bound variable. This condition implies that
constructors really construct objects of the corresponding inductive type.


\begin{definition}
  The type of a constructor $\Pi \xbold^\Abold. I \ldots$ satisfies the
  \emph{positivity condition} for the bound variable $I$ if for all argument
  types $A_i$ one of the following conditions are satisfied.
  \begin{itemize}
  \item The bound variable $I$ does not occur in $A_i$

  \item $A_i$ has the form $\Pi \zbold^\Bbold . I \ldots$ where the bound
    variable $I$ does not occur in any $B_j$.
  \end{itemize}
\end{definition}

All constructor types of an inductive definition must satisfy the positivity
condition. The positivity condition is needed to guarantee the termination of
recursive functions. In a pattern match all constructor arguments (beside the
parameters) are considered structurally smaller than the matched
expression. This must be valid even if the argument of the constructor is a
function returning an object of the inductive type. The returned object of a
function argument is considered structurally smaller than the match object as
well. However if we allow arbitrary functions (e.g. the identity function) as
arguments to constructors we can feed any object of the inductive type which
is not structurally smaller as an argument to the function and get a result
which is not structurally smaller either and the termination condition is
broken.

Example of an \emph{invalid} inductive type:
$$
\Inductive_{[],\; I:\Any,\, [I,\, I \to I, \, (I \to I) \to I]}
$$
If you look at the first two constructors this definition is equal to the
definition of natural numbers. However the third constructor does not satisfy
the positivity condition becaues the first argument type of the constructor is
a function type which has $I$ as an argument type. Therefore the term is
invalid.

If we modify the term slightly we get the \emph{valid} inductive type of
ordinals
$$
\Inductive_{[],\; I:\Any,\, [I,\, I \to I, \, (\Natural \to I) \to I]}
$$
Note that $I$ in the argument position of the constructor has been
replaced by the type $\Natural$ in which $I$ does not occur.




\subsubsection{Elimination Function}

\begin{definition}
  The elimination function
  $$
  \lambda \ybold^\Bbold x^T.R : \Pi \ybold^\Bbold x^T . s_R
  $$
  is a
  %
  \emph{valid elimination function}
  %
  for the inductive type
  $$
  T = \Inductive_{\Gamma,I:\Pi \ybold^\Abold.s_I,\Cbold} \, \pbold \,
  \abold
  $$
  in the following cases
  \begin{itemize}

  \item $s_I = \Any$

  \item $s_I = \Prop$ and $s_R = \Any$ and $T$ has either no constructor or
    one constructor with propositional arguments only.

  \end{itemize}
\end{definition}
%
In a case expression only valid elimination function can be used for the
following reasons:
\begin{itemize}

\item If $s_I = \Any$ then the inductive object is a computational object
  which exists at runtime. It is possible to return any other object by
  pattern match either a proof object or another computational object.

\item If $s_I = \Prop$ then the inductive object is a proof which will be
  erased in the runtime i.e. it does not exist during runtime.

  If the inductive type has no constructor, then the object cannot exist
  i.e. the path will never be entered at runtime.

  If the inductive object has one constructor with propositional arguments
  only (i.e. proofs only) then the remaining code will make sure that no
  computational information is extracted from the proof arguments. Furthermore
  there is only one constructor. Therefore no decision is made in the pattern
  match.

  If the inductive object has one constructor with a computational argument
  then then remaining code might use this argument for further processing
  which would make erasion of proofs impossible. Therefore it is not allowed.

  If the inductive object has more than one constructor then the pattern match
  makes a decision based on the actual constructor used. This decision is
  impossible in the runtime if the proof has been erased.
\end{itemize}



\subsubsection{Example: false}

Now let us look into some more examples of inductive types. We have already
defined the type of natural numbers and lists in the chapter
\ref{sec:terms}~Terms.
%
The simplest propositional inductive type with no parameters and no
constructors is
$$
\text{false} := \Inductive_{[], I:\Prop, []} : \Prop
$$
and represents the proposition $\text{false}$. Since it has no constructors,
it is impossible to construct an object of this type. An object of this type
can only be an assumption or a consequence of a false assumption.


From an inhabitant of false we can construct an inhabitant of any type i.e. it
is possible to define a function of type $\Pi A^\Any. \text{false} \to A$
which corresponds to the notion of logic \emph{ex falso quodlibet} or
\emph{from a wrong assumption you can conclude everything}.
%
Such a function can be defined as
$$
\lambda A^\Any p^\text{false}. \case(p, \lambda x^\text{false}. A, [])
: \Pi A^\Any. \text{false} \to A
$$
%
Every branch of the case expression returns an object of type $A$, but there
is no branch because the type has no constructors.

In source code we write
\begin{alba}
    class false: Proposition := -- no constructors

    exFalso (A: Any): false -> A
    := case -- no cases
\end{alba}


\subsubsection{Example: true}

If we add one trivial constructor we can encode the proposition $\text{true}$
as an inductive type.
%
$$
\text{true} := \Inductive_{[], I:\Prop, [I]} : \Prop
$$
whose unique inhabitant is the term $\Constructor^0_{\text{true}}$. The type
$\text{true}$ corresponds to the unit type of many functional languages here
defined for the sort $\Prop$.



\subsubsection{Example: Disjunction}

Logical disjunction can be expressed by the inductive type
$$
(\lor)
:=
\Inductive_{[a:\Prop, b:\Prop], I:\Prop, [a \to I, b \to I]}
:
\Prop \to \Prop \to \Prop
$$
%
In order to prove $a \lor b$ we need either a proof of the proposition $a$ or
a proof of the proposition $b$ and use the corresponding constructor to
construct a proof of $a \lor b$. The two propositions are parameters. If we
have a term $p_a: a$ then the term $\Constructor^0_{(\lor)} \, a \, b \, p_a$ has
type $a \lor b$. Note that the two propositions $a$ and $b$ are parameters and
therefore have to be provided as arguments to the constructor.

Since all proofs and propositions are erased in the runtime (we say that
proofs are computationally irrelevant) we cannot use a proof of $a \lor b$ to
make any computationally relevant decisions. But if we define the same
inductive type in the sort $\Any$ we get the type of decisions which are
usable in computations.


\subsubsection{Example: Decision}

$$
\Decision
:=
\Inductive_{[a:\Prop, b:\Prop], I:\Any, [a \to I, b \to I]}
:
\Prop \to \Prop \to \Any
$$
If we have a term $p_a:a$ then the term
$$
\Constructor^0_\Decision \, a \, b \, p_a
:
\Decision \, a \, b
$$
has the type of a decision and we can pattern match on the decision term in
computationally relevant parts of the program. A case expression matching on
the first constructor makes a proof of the first proposition available to the
first function of the case expression and matching on the second constructor
makes a proof of the second proposition available to the second function of
the case expression.

In source code we express the inductive type $\Decision$ as
%
\begin{alba}
  class Decision (a b:Proposition): Any create
    left:  a -> Decision a b
    right  b -> Decision a b
\end{alba}


\subsubsection{Example: Boolean}

In many functional languages there is a boolean type with two argumentless
constructors. Such a boolean type can be expressed in the calculus as
$$
\Boolean
:=
\Inductive_{[], I:\Any, [I, I]}
:
\Any
$$
A boolean type has the disadvantage that it encodes a decision but carries no
information about the decision it encodes. Therefore it is preferable to work
with decision types instead of boolean types.


\subsubsection{Example: Equality}

We can define the equality relation as an inductive type. In Alba two terms
are equal if and only if they are not distinguishable i.e. have the same
properties. This type of equality is called \emph{Leibniz equality}.
%
$$
(=)
:=
\Inductive_{[A:\Any, x:A], I:A\to\Prop, [I x]}
:
\Pi A^\Any. A \to A \to \Prop
$$
%
This definition is an example showing the difference between parameters and
index arguments. The definition has two parameters, the type of the terms to
be compared and a term of this type. The bound variable $I$ has type
$A\to\Prop$ which is a predicate describing if other terms of type $A$ are
equal to the parameter $x$.

This inductive definition has only one constructor which expresses the
triviality that $x$ is equal to itself. Since it is the only constructor, this
inductive definition allows to generate proofs of $e = e$ for any expression
$e$ {\scriptsize (note that the type of $e$ is treated as an implicit argument, to
  be precise we would have to write $(=) \, E \, e \, e$ where $E$ is the type
  of $e$)}.

However due to reduction in case of $d \reduce e$ we can conclude $e = d$ from
$e = e$ which allows to prove more complex equalities than the trivial
reflexivity.



\subsubsection{Example: Order Relation on Natural Numbers}

The order relation $\le$ on natural numbers has the type $\Natural \to
\Natural \to \Prop$ i.e. $i \le j$ is a proposition expressing the fact that
$i$ is less or equal $j$. Being a propositions it is a type. An object of this
type is a proof of the fact.
$$
(\le)
:=
\Inductive_{
  [],
  r:\Natural \to \Natural \to \Prop,
  [\Pi i^\Natural r 0 i ,\, \Pi i^\Natural j^\Natural. r i j \to r (i+1) (j+1)]
}
:
\Natural \to \Natural \to \Prop
$$
%
This is the first inductive type with arguments (i.e. indices) and no
parameters. Therefore the type of the bound variable in the inductive type is
not a sort as in all previously defined inductive types, it is the kind
$\Natural \to \Natural \to \Prop$ which is an abbreviation for
$\Pi x^\Natural y^\Natural. \Prop$.

There are two ways to construct an object of type $a \le b$. Either $a$ is
zero, then we can use the first constructor to generate the proof
$\Constructor^0_{(\le)} b: 0 \le b$. Or we have already a proof $p: i \le j$
and $a$ is the successor of $i$ and $b$ is the successor of $j$. Then we
generate the proof $\Constructor^1_{(\le)} i j p: a \le b$.

Our intuition about the order relation on natural numbers tells us that given
$n \le m$ we should be able to prove $n \le m + 1$. A proof of this
proposition is an object of type
$$
%
T = \Pi n^\Natural m^\Natural. n \le m \to n \le m + 1
$$
%
i.e. a function which takes two natural numbers $n$ and $m$ and a proof of the
proposition $n \le m$ and returns a proof of $n \le m + 1$.

A proof of $n \le m$ must have been constructed by an initial proof of $0 \le
m - n$ by using $\Constructor^0_{(\le)} (m - n)$ and then applying the second
constructor $n$ times.

A proof of $T$ is a recursive function (i.e. a fixpoint) which iterates over a
proof of $n \le m$.
%
$$
\begin{array}{l}
  \lambda n^\Natural m^\Natural p^{n \le m}.
  \\
  \quad\fix(
  \\
  \quad\quad f^T,
  \\
  \quad\quad \case (
  \\
  \quad\quad\quad
    p, \;
    \lambda i^\Natural j^\Natural q^{i \le j}\,.\, i \le j+1,
  \\
  \quad\quad\quad [
  \lambda j. \Constructor^0_{(\le)} (j+1),
  \\
  \quad\quad\quad\,
  \lambda i j q. \Constructor^1_{(\le)} i (j+1) (f i j q)])
  \\
  \quad\quad 2)
\end{array}
$$
The body of the recursive function is a pattern match on the proof $p: n \le
m$ which distinguishes two cases.
\begin{enumerate}
\item $n = 0$ and $p$ has been constructed by the first constructor which
  proves $0 \le m$. In this case we can use the first constructor to prove $0
  \le m + 1$.

\item $n$ and $m$ have predecessors $i$ and $j$ and the proof of $n \le m$ has
  been constructed by applying the second constructor to the arguments $i$,
  $j$ and a proof $q$ of $i \le j$. By applying the bound variable $f$ which
  has the same type $T$ to $i$, $j$ and $q:i \le j$ we get a proof of
  $i \le j + 1$ which can be converted by applying the second constructor to a
  proof of $\underbrace{i + 1}_{= n} \le \underbrace{j + 1}_{=m} + 1$ which is
  a proof of $n \le m + 1$.

  The proof $q:i \le j$ is structurally smaller than the proof $p: n \le
  m$. Therefore the recursive function is guaranteed to terminate. The
  fixpoint decreases on its third argument.
\end{enumerate}

This simple example demonstrates that it is mechanical but not trivial to
generate inductive proofs in the intermediate language. It is the task of the
compiler to do a lot of work to generate such an induction proof from little
guidance by the user. The compiler has to do a lot of type inference and proof
term generation.







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Advanced Inductive Types}
\label{sec:advanced-inductive-types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsubsection{Mutually Inductive Types}

We can define mutually inductive types.

\begin{alba}
    mutual
        class
            Tree A
        :=
            node: A -> Children A -> Tree A

        class
            Children A
        :=
            []: Children A

            (+:): Tree A -> Children A -> Children A
\end{alba}
%
and mutually recursive functions

\begin{alba}
    mutual
        flip (A: Any): Tree A -> Tree A
        :=
            case
                node a children :=
                    node a (flip children)

        flip (A: Any): Children A -> Children A
        :=
            case
                [] :=
                    []

                head +: tail :=
                    flip tail + flip head

    -- with the helper function
    (+) (A: Any): Children A -> Tree A -> Children A
    :=
        case
            [] :=
                \ tree -> tree +: []

            head +: tail :=
                \ tree ->
                    head +: (tail + tree)


\end{alba}






But note that for each such set of mutually inductive types there is always an
equivalent simple inductive type using indices
%
\begin{alba}
    class T := tree; forest

    class Tree A: T -> Any :=
        []: Tree A children

        node: A -> Tree A forest -> Tree A tree

        (+:): Tree A tree -> Tree A forest -> Tree A forest
\end{alba}
%
and a corresponding simple recursive function
%
\begin{alba}
    flip (A: Any) (t: T) (tree: Tree A t): Tree A t
    :=
        inspect t tree case
            [] :=
                []

            node a children :=
                node a <| flip forest children

            head +: tail :=
                flip forest tail + flip tree head

    -- helper function
    (+) (A: Any) (children: Tree A forest): Tree A tree -> Tree A forest
    :=
        inspect
            forest children
        case
            [] :=
                \ last := last +: []

            head +: tail :=
                \ last := head +: (tail + last)
\end{alba}

\begin{alba}
\end{alba}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Typing Rules}
\label{sec:typing-rules}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}
  The strict order relation $\prec$ on sorts is extended to terms by the following
  rule
  $$
  \ruleh
  {T \prec U}
  {\Pi x^A.T \prec \Pi x^A. U}
  $$
  i.e. if the result types of two function types with the same arguments type
  figure in the relation $\prec$ the the function types figure in the relation
  as well.
\end{definition}

\begin{definition}
  The reflexive, transitive and reduction closure of $\prec$ is used as the
  order relation $\le$ on terms and defined inductively by the rules
  \begin{description}
  \item[start]
    $$
    \rulev {T \prec U} {T \le U}
    $$

  \item[reflexive]
    $$
    T \le T
    $$

  \item[transitive]
    $$
    \rulev
    {T \le U \\ U \le V}
    {T \le U}
    $$

  \item[reduction]
    $$
    \ruleh
    {A \reduce B \, \lor B \reduce A}
    {A \le B}
    $$
  \end{description}
\end{definition}


\begin{definition}
  The \emph {typing relation} $\Gamma \vdash t:T$ which reads ``in the context
  $\Gamma$ the term $t$ has type $T$'' is defined by the rules
  \begin{description}
  \item[axiom]
    $$
    \ruleh
    {s_1 \prec s_2}
    {[] \vdash s_1 : s_2}
    $$

  \item[variable]
    $$
    \ruleh
    {\Gamma \vdash A: s}
    {\Gamma, x:A \vdash x:A}
    $$
    This rule allows to introduce a variable $x$ of type $A$ if the type of
    $A$ is a sort. Since $\Prop : \Any$ and $\Any : \Box$ are valid in the
    empty context we can always introduce a variable and get the valid
    judgements $[A: \Prop] \vdash A : \Prop$ and $[A: \Any] \vdash A : \Any$.

  \item[weaken]
    $$
    \rulev
    {\Gamma \vdash t: T
      \\
      \Gamma, x:A \vdash x:A}
    {\Gamma, x:A \vdash t : T}
    $$
    i.e. the introduction of a new variable does not invalidate a valid typing
    judgement.

  \item[product]
    $$
    \rulev
    {\Gamma \vdash A: s_1
      \\
      \Gamma,x:A \vdash B:s_2
      \\
      s_2 = \Prop \lor s_1 = s_2
    }
    {\Gamma \vdash \Pi x^A . B: s_2}
    $$

  \item[abstraction]
    $$
    \rulev
    {\Gamma \vdash \Pi x^A . B: s
      \\
      \Gamma,x:A \vdash e:B
    }
    {\Gamma \vdash \lambda x^A . e : \Pi x^A . B}
    $$

  \item[application]
    $$
    \rulev
    {\Gamma \vdash f: \Pi x^A . B
      \\
      \Gamma \vdash a:A
    }
    {\Gamma \vdash f \, a : B[x:=a]}
    $$

  \item[reduction]
    $$
    \rulev
    {\Gamma \vdash t : T
      \\
      T \reduce U \lor U \reduce T
    }
    {\Gamma \vdash t: U}
    $$

  \item[subtype]
    $$
    \rulev
    {\Gamma \vdash t : T
      \\
      T \prec U
    }
    {\Gamma \vdash t: U}
    $$
    in words: If a term $t$ has type $T$ and $U$ is a supertype of type $T$,
    then the supertype $U$ is a type of $t$ as well.

  \item[inductive type]
    $$
    \rulev
    { T = \Pi \pbold^\Pbold \xbold^\Abold.s
      \\
      \Gamma, I:T \vdash I:T
      \\
      \forall i\;.\; C_i = \Pi \ybold^{\Bbold_i}. I \,\pbold \, \abold_i
      \;\text{\small(constructor type with positivity)}
      \\
      \forall i\;.\, \Gamma, I:T, \pbold:\Pbold \vdash C_i : s
    }
    {
      \Gamma \vdash
      \Inductive_{[\pbold:\Pbold], I:T, [C_0,C_1,\ldots]}
      :
      T
    }
    $$
    where the conditions above the line require
    \begin{enumerate}
    \item $T$ must be a kind.

    \item $T$ is a valid type so that a
      variable can be defined which has that type.

    \item The types $C_i$ are constructor types for the variable $I$ which
      satisfy the positivity condition (if the inductive
      type appears in an argument type is either the argument type or a
      function type where the inductive type does not occur in the argment
      types, only in the result type).

    \item The constructor types $C_i$ are valid types in a context with the
      parameters and a bound variable $I$ of type $T$.
    \end{enumerate}


  \item[constructor]
    $$
    \rulev
    {
      U = \Inductive_{[\pbold:\Pbold], I:T, \Cbold}
      \\
      \Gamma
      \vdash
      U
      :
      \Pi \pbold^\Pbold.T
      \\
      j < |\Cbold|
    }
    {
      \Gamma \vdash
      \Constructor^j_U
      :
      \Pi \pbold^\Pbold \,.\, C_j[I := U]
    }
    $$
    This rule says that the type of a constructor expression
    $\Constructor^j_{\Inductive_{\ldots}}$ is the corresponding constructor type
    of the inductive definition where the bound variable $I$ has been
    substituted by the actual inductive type.


  \item[pattern match]
    $$
    \rulev
    {
        T = \Pi \ybold^\Abold. s_I
        \\
        \forall i\;.\; C_i = \Pi \zbold^{\Bbold_i}. I \, \abold_i
        \\
        U =
            \Inductive_{
                [\pbold:\Pbold],
                I: T,
                [C_0, C_1, \ldots]}
        \\
        \Gamma \vdash U \qbold: T
        \\
        \Gamma, \ybold^\Abold, x^{U\qbold\ybold} \vdash R: s_R
        \\
        U \text{ can eliminate to } s_R
        \\
        F = \lambda \ybold^\Abold x^{U\qbold\ybold}. R
        \\
        \forall i\;.\;
            \Gamma
            \vdash
            f_i: \Pi \zbold^{\Bbold_i}. 
                F\, 
                \abold_i\, 
                (\Constructor^i_U \qbold\zbold)
    }
    {
        \Gamma
        \vdash
        \case(\fbold, F)
        : \Pi \ybold^\Abold x^{U\qbold\ybold} . F \ybold x
    }
    $$

  \item[fixpoint]
    TODO

  \end{description}
\end{definition}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Typing Judgements}
\label{sec:typing-judgements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The first version of the language has the only sorts
$\Prop \prec \Any \prec \Box$ and not the cumulative hierarchy of universes
$\Prop \prec \Any_0 \prec \Any_1 \prec \ldots$.

Cumulative universes shall be avoided as long as possible, not because they
are difficult to implement, but because it is difficult to output
understandable error messages in case of universe inconsistencies.

In the following we try to explore what typing judgements are possible without
cumulative universes.




\subsubsection{Basic Judgements}


$$
\begin{array}{llllll}
  [] &\vdash
  & \Prop &:& \Any &

  \\

  [] &\vdash
  & \Any &:& \Box &

  \\

  [] &\vdash
  & \underbrace{\Pi A^\Any . \Any}_{=\, \Any \to \Any} &:& \Box &

  \\

  \Gamma, A:\Any &\vdash
  & A \to \Prop &:& \Any &

  \\

  [] &\vdash
  & \lambda A. A \to \Prop &:& \Any \to \Any
\end{array}
$$

The last term is a function mapping a type to a predicate over the type
according to the reduction
%
$(\lambda A . A \to \Prop) \Natural \reduce \Natural \to \Prop: \Any$.



\subsubsection{Polymorphic Identity Function}

$$
\begin{array}{llllll}
  \Gamma, A:\Any &\vdash
  & A \to A &:& \Any

  \\

  [] &\vdash
  & \Pi A^\Any. A \to A &:& \Box

  \\

  [] &\vdash
  & \lambda A^\Any x^A. x &:& \Pi A^\Any. A \to A
\end{array}
$$
%
The last term represents a polymorphic identity function which has two
arguments. The first argument is the type and the second argument is an object
of this type which is mapped to itself.

It is not possible to apply the polymorphic identity function to itself
because feeding its type as a first argument violates the typing relation
($\Pi A^\Any. A \to A: \Any$ is not a valid typing judgement).

With cumulative universes this is not possible either. But it would be
possible to declare two polymorphic identity functions in different universes
and feed the function of the lower universe as an argument into the function
of the higher universe.



\subsubsection{Impossible Function Arguments}

All terms $T$ of type $\Box$ as its minimal type can never be used as an
argument to a function. This is because the most general type of a function
(with respect to its argument) looks like $\Pi A^\Any. B$. Since
$\Box \le \Any$ is invalid (it contradicts $\Any < \Box$), $T$ cannot be an
argument.

We have $\Any : \Box$, therefore $\Any$ cannot used as an argument.

Note that only $T:\Box$ cannot be used as arguments, $t:T$ can be used!






\subsubsection{Uninhabited Types}


$$
\begin{array}{llllll}
  [] &\vdash
  & \Pi A^\Any. A &:& \Box

  \\

  [] &\vdash
  & \Pi p^\Prop. p &:& \Prop
\end{array}
$$

The term $\Pi A^\Any. A $ is the type of a function which receives any type as
argument and returns an object of this type. There cannot be any object of
this type unless there are contradictory assumptions. If there were objects of
that type, we could feed any proposition as argument and get a proof of the
proposition as output.

The second type is more specific for propositions. But the same argument
applies. Note that the second type can be used as an argument while the first
cannot.



\subsubsection{Impredicativity of $\Prop$}

The typing rule for the dependent product has two sorts $s_1$ and  $s_2$. In
case that the second sort is $\Prop$, the typing rule reads
%
$$
\rulev
{
  \Gamma \vdash A: s
  \\
  \Gamma, x:A \vdash B:\Prop
}
{\Gamma \vdash \Pi x^A. B : \Prop}
$$
%
i.e. whenever the return type of a function type $B$ is a proposition, then the
whole function type is a proposition as well (note $B:\Prop$ must be valid an
\emph{not} $B = \Prop$!).

This has the consequence that the function type (which is a proposition) can
be used as an argument to any function which expects a proposition as argument
type. In case that $A = \Prop$ the type can used as an argument of a function
of this type. This property is called impredicativity.

Some impredicate definitions:
%
$$
\begin{array}{llllll}
  [] &\vdash
  & \Pi p^\Prop. p &:& \Prop
  & \text{\emph{``false''}}

  \\

  [] &\vdash
  & \Pi p^\Prop. p \to p &:& \Prop
  & \text{\emph{``true''}}

  \\

  [] &\vdash
  & \Pi p^\Prop q^\Prop r^\Prop. (p \to q \to r) \to r &:& \Prop
  & \text{\emph{``and''}}

  \\

  [] &\vdash
  & \Pi p^\Prop q^\Prop r^\Prop. (p \to q)  \to (p \to r) \to r &:& \Prop
  & \text{\emph{``or''}}
\end{array}
$$

These definitions demonstrate that no inductive definitions are necessary to
define logical connectives. They are quite useful and better understandable
than the equivalent impredicative definitions. But not strictly necessary.

A proof of \emph{true} is quite simple
$$
  [] \vdash
  \lambda p x. x :  \Pi p^\Prop. p \to p
$$






\subsubsection{Predicativity of $\Any$}

If we combine the typing rule for the dependent product for $s_2 \ne \Prop$
with the subtyping rule, then we get the rule

$$
\rulev
{
  \Gamma \vdash A: s_1
  \\
  \Gamma, x:A \vdash B: s_2
  \\
  s_2 \ne \Prop
}
{\Gamma \vdash \Pi x^A.B : \text{max}(s_1,s_2)}
$$

In case we wanted to use the type $\Pi x^A.B$ as an argument to an object of
its type, then it would require $\text{max}(s_1,s_2) \le A$ which is only
possible if $A$ is a sort and then contradicts $A < s_1$ because
$\text{max}(s_1,s_2) < s_1$ is not possible.

Therefore we say that $\Any$ is impredicative. The same argument applies for
the infinite hierarchy $\Prop \prec \Any_0 \prec \Any_1 \prec \ldots$.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Abstract Datatypes}
\label{sec:abstract-datatypes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent Status: Draft

An abstract datatype is a type with certain properties. In order to define the
type we need a context of parameters, a bound variable as a representant of
the type and a context describing postulated properties of that type
$$
\Abstract_{\Gamma, T:K, \Delta}
$$
where $\Gamma = [p_0:P_0, p_1:P_1, \ldots]$ is a context of parameters, $K$ is a
kind (i.e. $T$ can represent a type constructor needing arguments),
$\Delta = [d_0:D_0, d_1: D_1, \ldots]$ and the bound variable $T$ occurs in
each $D_i$.

An abstract datatype can be instantiated by applying it to a specific datatype
with the required properties $d_0, d_1, \ldots$. I.e. its type is a function.

$$
\Abstract_{\Gamma,T^K,\Delta}
:
\Pi \Gamma T^K \Delta. \Any
$$

\subsubsection{Example: Group}
A group has no parameters. The type of the bound variable $T$ of a group is
$\Any$ i.e. it represents a type which is the type of a group element. The
context $\Delta$ is defined as
$$
\begin{array}{llll}
  \Delta =
  &[
  & 0: T
  & \text{neutral element}
  \\
  &
  & (+): T \to T \to T
  & \text{binary function}
  \\
  &
  & (-): T \to T
  & \text{inversion}
  \\
  &
  & a: \Pi x^T y^T z^T. x + y + z = x + (y + z)
  & \text{associativity}
  \\
  &
  & n: \Pi x^T. x + 0 = x
  & 0 \text{ is neutral with respect to } +
  \\
  &
  & i: \Pi x^T. x + (-x) = 0
  & -x \text{ is the inverse element of } x
  \\
  &]
\end{array}
$$






\subsubsection{Example: Sortable}

A sortable has no parameters. The type of the bound variable $T$ of a sortable
is $\Any$ i.e. it represents a type which is the type of sortable
elements. The context $\Delta$ is defined as
$$
\begin{array}{llll}
  \Delta =
  &[
  & (\le): T \to T \to \Prop,
  & \text{order relation}
  \\
  &
  & (\le_d): \Pi x^T y^T . \Decision\,(x \le y)\, (\lnot\, x \le y)
  & \text{decision function}
  \\
  &
  & r: \Pi x^T y^T. x \le y
  & \text{reflexivity}
  \\
  &
  & t: \Pi x^T y^T z^T. x \le y \to y \le z \to x \to z
  & \text{transitivity}
  \\
  &]
\end{array}
$$


\subsubsection{Example: Monad}

A monad has no parameters. The type of the bound variable $T$ is $\Pi
A^\Any. \Any$, i.e. $T$ is a type constructor needing one type argument like
e.g. list.  The context $\Delta$ is defined as
$$
\begin{array}{llll}
  \Delta =
  &[
  & r: \Pi A^\Any x^A. T A,
  & \text{return}
  \\
  &
  & b: \Pi A^\Any B^\Any m^{T A} f^{A\to T B}. T B
  & \text{bind}
  \\
  &
  & u: \Pi A^\Any B^\Any x^A f^{A\to T B}. b A B (r A x) f = f x
  & \text{unit}
  \\
  &
  & a: \Pi \ldots . b B C (b A B m f) g = b A C m (\lambda x^A. b B C (f x) g)
  & \text{associativity}
  \\
  &]
\end{array}
$$
Associativity is not spelled out completely in detail here, because the
expression becomes too long. The many needed type arguments obscure a little
bit the essence of the axioms. By being sloppy and leaving out the type
arguments the associativity condition becomes
$$
  b (b m f) g = b m (\lambda x. (f x) g)
$$
which says that doing the bind step by step and first combining the two
functions and then doing the bind must be the same.

In program text we define a monad by
\begin{alba}
   abstract class
     Monad: Any -> Any
   section (A B C: Any) (M: Monad) :=
     return: A -> M A

     (|>): M A -> (A -> M B) -> M B

     unit (a: A)
          (f: A -> M B)
          : (return a |> f) = f a

     assoc (m: M A)
           (f: A -> M B)
           (g: B -> M B)
           : m |> f |> g  =  m |> (\a := f a |> g)
\end{alba}

Remark: This is not yet very clean and needs some rework. In the class header
the name \code{Monad} is used as if it were the type constructor. In the
section part the name is used as if it were the type of the type constructor.




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main_alba_design"
%%% End:
