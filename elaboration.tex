\chapter{Elaboration}

The problem of elaboration is to read an Alba source code file and build terms
and definitions in the intermediate language. In order to do this, overloaded
symbols have to be resolved and implicit arguments have to derived.

During the development of Alba I initially had completely underestimated the
complexity of the task. In other dependently type languages like
Idris~\cite{brady2013}, Agda~\cite{norell2007} and Lean~\cite{demoura2015} papers
have been written to describe the complex procedure.

In Alba we have the additional complexity that Alba shall be a language for
beginners and experts. The beginners should not be bothered with the complexity
of dependent types. Alba shall \emph{feel} like a simple functional programming
language. However the most powerful features of dependent types shall be
available in the language and the user should be able to grasp the power step by
step. I.e. the learning curve shall be flat and not steep.



\section{Implicit Arguments}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{Overloading}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Overloading means that the same name can be used for different
functions/constants. E.g. the operator $+$ can be addition for different type of
numbers like \code{Int} or \code{Float} or e.g. string concatenation. The
function \code{length} can be applied to a list, an array or a string argument.

Ambiguities shall be resolved in the context where the functions/constants are
used.

We have two different problems to solve:
\begin{enumerate}

\item Filter global ambiguous symbols before entering the context:
Functions/constants in the context with the same name shall be different either
for some explicit argument types or at the result type.

We shall not allow ambiguities in the global context which cannot be
distinguished by some explicit argument type or the result type.


\item Resolve ambiguities at usage: At the actual usage overloaded symbols shall
be resolvable.

\end{enumerate}

A type in normal form is either
\begin{enumerate}

\item a sort i.e. $\Prop$ or $\Any$.

\item a product $\Pi x^A. B$

\item a variable application $v a_0 a_1 \ldots$

\item a pattern match application
    $\case(\lambda \vec{y}^\vec{B} x^T. R, \vec{f}) \,\vec{a}\, e\, \ldots$
    %
    where $\vec{a}$ are the index arguments and $e$ is the object of the
    inductive type which is not a constructor expression.

\item a fixpoint application
    $\fix(x^T := t, k)\, \vec{a}\, e\, \ldots$
    %
    where $k = |\vec{a}|$ and $e$ is not a constructor expression.
\end{enumerate}
%
Due to the typing rules lambda abstractions cannot be types.





\subsection{Filter Overloaded Symbols}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Comparing Types by Signatures}

We want to filter definitions before they enter the global context such that
only \emph{useful} overloadings are possible. The question: What is
\emph{useful}?

It is clearly useless to allow a symbol to be overloaded if both definitions
have the same type in normal form. This would create an ambiguity which can
never be resolved neither by type annotations, nor by actual argument types nor
by the required result type.

We allow overloadings only if the corresponding types differ significantly on
explicit arguments and the result type.

In order to compare types we convert them into a signatures. The atomic elements
of a signature are global names (e.g. \code{List}, \code{Int}, ...), sorts
represented by \code{Sort}, implicits
(represented by \code{I}) and unknowns (represented by \code{U}).

An element of a signature is either an atomic or an application.
\begin{alba}
    I
    U
    Int
    List U
    Array Nat
    Equal U U
    U U
\end{alba}

A signature is a list of elements or signatures where the last element is an
element. A signature has at least one entry representing the result type. The
optional entries before the last one represent the arguments. Examples
\begin{alba}
    [Int, Int, Int]
    [Float, Float, Float]
    [I, U, U, U]
    [I, U, List U, List U]
    [I, I, U, [U, U], U]
\end{alba}

When comparing signatures we do a structural comparison ignoring all implicit
argument positions. An unknown is not different from any other entry at the same
position. An unknown at the end is not different from any signature which has
more arguments.

Some examples of signatures
\begin{alba}
    (+): Int -> Int -> Int

        [Int, Int, Int]


    (+): String -> String -> String

        [String, String, String]


    identity: all {A: Any}: A -> A

        [I, U, U]
\end{alba}

Clearly the first two signatures are different. However the third is not
different from the first two. The significant part of the third signature is
\code{[U, U]} where the first unknown is neither different from \code{Int} nor
\code{String} and the second unknown is not different from the rest of both
other signatures because the second unknown is at the end.

The pipeline operator \code{|>} and the application operator \code{<|} have some
very general signatures.
\begin{alba}
    (|>): all {A: Any} {B: A -> Any} (a: A) (f: all x: B x): B a

        [I, I, U, [U, U], U]


    (<|): all {A: Any} {B: A -> Any} (f: all x: B x) (a: A): B a

        [I, I, [U, U], U, U]
\end{alba}

The type $\Pi A^\Any. A$ is the most general type and has the most general
signature.
\begin{alba}
    all {A: Any}: A

        [U]
\end{alba}



All other functions which act like attributes can be easily overloaded. Let's
look into the example of the \code{length} function.

\begin{alba}
    length: all {A: Any}: List A -> Int

        [I, List U, Int]


    length: all {A: Any}: Array A -> Int

        [I, Array U, Int]
\end{alba}

More example of signatures.
%
\begin{alba}

    Equal: all {A: Any}: A -> A -> Proposition

        [I, U, U, Sort]


    Plus {A: Any} (R: Endorelation A): Endorelation A

        [I, [U, U, Sort], U, U, Sort]


    naturalInduction
        {P: Predicate Natural}
        (zero: P zero) (step: all {i}: P i -> P (add1 i))
        {n}: P n

        [I, U, [U,U], I, U]


    listInduction
        {A: Any} {P: Predicate (List A)}
        : P [] -> (all {a l}: P l -> P (a :: l)) -> {l} -> P l

        [I, I, U, [U,U], I, U]


    lessEqualInduction {R: Endorelation Natural}
        :   (all {n}: R zero n)
            -> (all {n m}: LessEqual n m -> R n m -> R (add1 n) (add1 m))
            -> all {n m}: LessEqual n m -> R n m

        [I, U, [I, I, LessEqual U U, U, U], LessEqual U U, U]
\end{alba}

Note that everything which is neither an implicit argument nor a global function
nor a sort is \emph{unknown}. Applications of implicit arguments to any
arguments are \emph{unkown} in the signature.





\subsubsection{Computed Types}

In Alba types can be computed as well. Two examples to demonstrate a computed
type.
%
\begin{alba}
    (inspect n case
        zero := True
        add1 i := False)

    (inspect n case
        zero := Int
        add1 i := List Int)
\end{alba}
%

Since computed types can have any forms we consider them as unknown in
signatures.










\subsection{Resolve Ambiguities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

During the elaboration of a term, the possible ambiguities have to be resolved.
There are only two sources for ambiguity:
%
\begin{enumerate}

\item Overloaded global symbols like $+$ and \code{length}

\item Literal numbers (they can have type \code{Int}, \code{Float},
\code{Natural}, etc.).

\end{enumerate}








\section{Metavariables and Unification}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Metavariables}

We use metavariables or holes to describe terms which have to be derived by
unification. There are some reasons to introduce metavariables.

\begin{itemize}

\item Implicit arguments

\item Untyped variables

\item Required types for terms which do not have an explicit required type.

\item Convert the type of an untyped variable to a function type.

\end{itemize}


The context of elaboration has 3 types of variables.

\begin{itemize}

\item Constants: All variables which have already been in the context at the
start of elaboration.

\item Free variables: All variables introduced to start the elaboration of an
abstraction, a function type or a where expression.

\item Bound variables: Variables shifted into the context during unification to
unify abstractions, function types or where expressions.

\end{itemize}

In the elaboration procedure of the lean theorem prover described in
\cite{demoura2015} metavariables are defined in a way such that they can only
instantiated by closed terms i.e. by terms which do not contain neither free
variables nor bound variables.

This can be achieved by using metavariables of the form $\meta{M}: \Pi
\vec{x}^{\vec{A}}.T$ where $\vec{x}$ is the collection of all free variables and
using the metavariable only in the form $\meta{M} \vec{x}$.

Whenever we try to unify
$$
    \meta{M} \vec{x} \le T
$$
we get the solution
$$
\begin{array}{lll}
    \meta{M} &:=& \lambda \vec{x}^{\vec{A}}. T

    \\

    \meta{M} \vec{x} &\leadsto& T
\end{array}
$$

It is not yet clear if such a form of introducing metavariables is really
necessary. But this form has the advantage to include in each introduction of a
metavariable the variables on which it can depend. The unification problem
$\meta{M} \vec{x} \le T$ indicates that $T$ is allowed to depend only on the
variables $\vec{x}$. If $T$ contains more variables, we can reject the
instantication of $\meta{M} := \lambda \vec{x}^{\vec{A}}. T$ because the
definition term is not closed.

If we don't use this scheme to introduce metavariables we have to make sure that
metavariables are not instantiated inconsistently.




\subsection{Unification}

Unification is usually triggered during elaboration of an application. The type
of the actual argument must be a subtype of the argument required from the
function term. Therefore a unification problem usually starts with
$$
    A \le R
$$
where $A$ is the type of the actual argument and $R$ is the required type of the
argument.



\section{Elaboration Primitives}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Each term elaboration needs a required type. If there is no explicit required
type, we introduce a metavariable for that type. The elaboration of the term
fills the metavariable.



\subsection{Sort}

There are only two sorts to build: \code{Proposition} and \code{Any}. The
allowed required types are
\begin{itemize}

\item for \code{Proposition}: $\Any_i$ or a metavariable whose type is
at least $\Any_1$.

\item for \code{Any}: $\Any_i$ for $0 < i$ or a metavariable whose type is at
least $\Any_2$.

\end{itemize}



\subsection{Variable}


\subsection{Typed Term}


\subsection{Product}



\subsection{Application}



\subsection{Abstraction}


\subsection{Pattern Match}


\subsection{Fixpoint}









\section{Where Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Example}

\begin{alba}
    1 + f 10
    where
        f x := 2 * x + 25
\end{alba}

We need a metavariable for the type of $f$ and introduce $f$ as a free variable
into the context, i.e. we need the context
$$
    \Gamma, {\meta{T}_f}^{\Any_1}, f^{\meta{T}_f}
$$

In this context start to analyze \code{1 + f 10}. $+$ is an overloaded symbol
for the various numbers and other overloadings. After seeing the number $1$ as
the first argument, only addition of numbers remains. But it still remains
ambiguous.

In trying to elaborate the second argument \code{f 10} we have as the required
type one of the possible numbers. Now the elaboration becomes stuck, because the
elaboration of \code{10} is ambiguous and we don't want to nest ambiguities.

So we have to elaborate the local definition next. We have to add a metavariable
$\meta{T}_x$ for the type of $x$ and the free variable $x$ to the context.
$$
    \Gamma, {\meta{T}_f}^{\Any_1}, f^{\meta{T}_f}, {\meta{T}_x}^{\Any_1}, x^{\meta{T}_x}
$$

The we elaborate \code{2*x + 25} with any of the possible number types as the
required type. This elaboration is unique for any of the number types and
assigns the corresponding number type to the metavariable $\meta{T}_x$.

Elaborating the abstraction we get
$$
    (\lambda x^N. 2x + 25): \Pi x^N. N
$$
where $N$ is the corresponding number type. Now we get the assignment $\meta{T}_f
:= \Pi x^N. N$ and can continue with the elaboration of \code{f 10}.


\vskip 5mm
\subsubsection{General Case}

Draft: $\equiv, \approx, \cong, \simeq, \doteq, \precapprox, \precsim, \lesssim,
\gtrsim$.



\begin{alba}
    body
    where
        a := def   -- 'def' can be '\ x y ... := e'

    body
    where
        f x y .. := def
\end{alba}
