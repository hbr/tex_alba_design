\chapter{Elaboration}

The problem of elaboration is to read an Alba source code file and build terms
and definitions in the intermediate language. In order to do this, overloaded
symbols have to be resolved and implicit arguments have to derived.

During the development of Alba I initially had completely underestimated the
complexity of the task. In other dependently type languages like
Idris~\cite{brady2013}, Agda~\cite{norell2007} and Lean~\cite{demoura2015} papers
have been written to describe the complex procedure.

In Alba we have the additional complexity that Alba shall be a language for
beginners and experts. The beginners should not be bothered with the complexity
of dependent types. Alba shall \emph{feel} like a simple functional programming
language. However the most powerful features of dependent types shall be
available in the language and the user should be able to grasp the power step by
step. I.e. the learning curve shall be flat and not steep.



\section{Implicit Arguments}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{Overloading}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Overloading means that the same name can be used for different
functions/constants. E.g. the operator $+$ can be addition for different type of
numbers like \code{Int} or \code{Float} or e.g. string concatenation. The
function \code{length} can be applied to a list, an array or a string argument.

Ambiguities shall be resolved in the context where the functions/constants are
used.

We have two different problems to solve:
\begin{enumerate}

\item Filter global ambiguous symbols before entering the context:
Functions/constants in the context with the same name shall be different either
for some explicit argument types or at the result type.

We shall not allow ambiguities in the global context which cannot be
distinguished by some explicit argument type or the result type.


\item Resolve ambiguities at usage: At the actual usage overloaded symbols shall
be resolvable.

\end{enumerate}

A type in normal form is either
\begin{enumerate}

\item a sort i.e. $\Prop$ or $\Any$.

\item a product $\Pi x^A. B$

\item a variable application $v a_0 a_1 \ldots$

\item a pattern match application
    $\case(\lambda \vec{y}^\vec{B} x^T. R, \vec{f}) \,\vec{a}\, e\, \ldots$
    %
    where $\vec{a}$ are the index arguments and $e$ is the object of the
    inductive type which is not a constructor expression.

\item a fixpoint application
    $\fix(x^T := t, k)\, \vec{a}\, e\, \ldots$
    %
    where $k = |\vec{a}|$ and $e$ is not a constructor expression.
\end{enumerate}
%
Due to the typing rules lambda abstractions cannot be types.





\subsection{Filter Overloaded Symbols}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{First Try with Equivalence Relation}

In order to filter overloaded symbols we could try to find some equivalence
relation on types. Whenever two types are equivalent, there cannot be a name for
these two types. The equivalence relation shall satisfy the following
requirements:

\begin{itemize}

\item If two types are not equivalent, then both types must be distinguishable
by their explicit argument types and the result type.

\item The equivalence relation must not be too coarse to allow for useful
overloadings.

\end{itemize}

The optimal equivalence relation would be

\begin{quote}
    Two types are equivalent if they have the same number of explicit arguments
    and they cannot be distinguished by their argument types and the result
    type.
\end{quote}

The finest possible equivalence relation would be beta-equivalence i.e. two
types are considered equivalent if they have the same normal form. But this
equivalence relation is too fine. Consider the two types
%
\begin{alba}
    all {A: Any}: A -> A -> A

    Int -> Int -> Int
\end{alba}
%
which are not equivalent according to this equivalence relation.

However we cannot distinguish these two types by argument types and the result
type.

Given two arguments of type \code{Int} and a required result type of \code{Int},
both types are valid and an ambiguity cannot be resolved. Therefore we need a
more coarse equivalence relation which puts both types into the same equivalence
class.

A very coarse relation would be to consider two types equivalent which describe
a function with the same number of explicit arguments. But this relation is too
coarse, because it puts the following three types into the same equivalence class
%
\begin{alba}
    all {A: Any}: List A -> Natural

    all {A: Any}: Array A -> Natural

    String -> Natural
\end{alba}
%
With that equivalence relation we could not have a function named \code{length}
which works on lists, arrays and string.



\subsubsection{Preorder and Signatures}

If we look more into the details of the following types
%
\begin{alba}
    all {A: Any}: A -> A -> A

    Int -> Int -> Int

    String -> String -> String
\end{alba}
%
we see that an equivalence relation is not the appropriate tool. Certainly the
second and the third are not equivalent and could therefore be named with the
same symbol. The problem here: The first type is more general than the second
and the third. Therefore its to possible to have a symbol which has all three
types.

What we really need is some preorder on types. Let's call this preorder
\emph{includes}. Certainly \code{Int -> Int -> Int} includes itself. The types
\code{Int -> Int -> Int} and \code{String -> String -> String} do not figure in
the relation and \code{all \{A:Any\}: A -> A -> A} includes \code{Int -> Int ->
Int} and the corresponding string type as well.

The rule: We do not allow a symbol which has two possible types where one
includes the other.

In the following we transform a type into a signature and define a
\emph{includes} relation on the signatures. The \emph{includes} relation on
signatures is a partial order. Therefore the corresponding relation on types is
a preorder.

The primitive elements are global names (like \code{Int}, \code{List}), unknowns
\code{U} representing implicit arguments and \code{Sort}. Global names and sorts
do include only themselves. The unknowns include all other primitive elements.

Global names can be applied to arguments. We can form
\begin{alba}
    List U

    List Int

    Equal U U \end{alba}
%
The \emph{includes} relation extends to applications in a natural manner.
\code{List U} includes \code{List Int} and \code{List String}.

We use these elements to describe signatures. The operator $+$ has the
signatures
%
\begin{alba}
    (+): Int -> Int -> Int

        [Int, Int, Int]


    (+): String -> String -> String

        [String, String, String]
\end{alba}
%
The last type in a signature is always the final result type and the first types
are the signatures of the argument types.


Highly polymorphic functions have highly general signatures.
%
\begin{alba}
    (|>): all {A: Any} {B: A -> Any} (a: A) (f: all {x}: B x): B x

        [U, [U, U], U]
\end{alba}
%
Note that the description of the result type in this signature is unknown. It
can be anything even a function being able to take more arguments. Therefore the
number of actual explicit arguments of an application of a symbol of this
signature can be more than two.

The second explicit argument of this signature is a function type whose return
type is generic. If the function returns a function, it can be applied to more
arguments.

The most general type (i.e. the most inclusive type) is $\Pi A^\Any. A$ whose
signature is
\begin{alba}
    [U]
\end{alba}
%
This signature includes all other signatures. Therefore a symbol of type $\Pi
A^\Any. A$ does not allow any overloading. Fortunately a symbol of that type in
the global context would imply that the context is inconsistent, because
anything can be proved and generated having a symbol of this type.

But there are other signatures which are rather general. E.g. the signature of
the polymorphic identity function
%
\begin{alba}
    identity: all {A: Any}: A -> A

        [U, U]
\end{alba}
%
includes the signature of any other function with an arbitrary number of
arguments. Therefore it is practically impossible to overload the symbol
\code{identity}. Only local names can be \code{identity} because local names
shadow all other names introduced before.

All other functions which act like attributes can be easily overloaded. Let's
look into the example of the \code{length} function.

\begin{alba}
    length: all {A: Any}: List A -> Int

        [List U, Int]


    length: all {A: Any}: Array A -> Int

        [Array U, Int]
\end{alba}
%
However the introduction of a specific \code{length} function would cause an
illegal overloading
\begin{alba}
    length: all {A: Any}: List String -> Int

        [List String, Int]
\end{alba}
because the signature of the more general \code{length} function on lists above
includes this signature.


More example of signatures.
%
\begin{alba}

    Equal: all {A: Any}: A -> A -> Proposition

        [U, U, Sort]


    Plus {A: Any} (R: Endorelation A): Endorelation A

        [[U,U,Sort], U, U, Sort]


    naturalInduction
        {P: Predicate Natural}
        (zero: P zero) (step: all {i}: P i -> P (add1 i))
        {n}: P n

        [U, [U,U], U]


    listInduction
        {A: Any} {P: Predicate (List A)}
        : P [] -> (all {a l}: P l -> P (a :: l)) -> {l} -> P l

        [U, [U,U], U]


    lessEqualInduction {R: Endorelation Natural}
        :   (all {n}: R zero n)
            -> (all {n m}: LessEqual n m -> R n m -> R (add1 n) (add1 m))
            -> all {n m}: LessEqual n m -> R n m

        [U, [LessEqual U U, U, U], LessEqual U U, U]

\end{alba}




\subsubsection{Computed Types}

In Alba types can be computed as well. Two examples to demonstrate a computed
type.
%
\begin{alba}
    (inspect n case
        zero := True
        add1 i := False)

    (inspect n case
        zero := Int
        add1 i := List Int)
\end{alba}
%
In computed types each branch of the pattern match can return a different type.
Therefore we have to allow set of types in signatures. The above two types have
the signatures
%
\begin{alba}
    {True, False}

    {Int, List Int}
\end{alba}

Note that computed types are always dependent. They depend on some object on
which the pattern match is done.







\subsubsection{General Relation}

Looking more into corner cases reveals that the \emph{includes} relation is not
yet the correct form of the relation. Look at the two signatures.
%
\begin{alba}
    [Int, U]

    [U, String]
\end{alba}

Both would be satisfied by an argument type \code{Int} and a result type
\code{String}. Therefore we have to consider both as \emph{related}.

As general rule we allow symbol overloading only if any pairs of types have
signatures which are unrelated. In other words: No two signatures of the types
of an overloaded symbol can be related.










\subsection{Resolve Ambiguities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

During the elaboration of a term, the possible ambiguities have to be resolved.
There are only two sources for ambiguity:
%
\begin{enumerate}

\item Overloaded global symbols like $+$ and \code{length}

\item Literal numbers (they can have type \code{Int}, \code{Float},
\code{Natural}, etc.).

\end{enumerate}








\section{Metavariables and Unification}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We use metavariables or holes to describe terms which have to be derived by
unification. There are two reasons to introduce metavariables.

\begin{itemize}

\item Implicit arguments

\item Untyped variables

\item Required types for terms which do not have an explicit required type.

\item Convert the type of an untyped variable to a function type.

\end{itemize}


The context of elaboration has 3 types of variables.

\begin{itemize}

\item Constants: All variables which have already been in the context at the
start of elaboration.

\item Free variables: All variables introduced to start the elaboration of an
abstraction, a function type or a where expression.

\item Bound variables: Variables shifted into the context during unification to
unify abstractions, function types or where expressions.

\end{itemize}

In the elaboration procedure of the lean theorem prover described in
\cite{demoura2015} metavariables are defined in a way such that they can only
instantiated by closed terms i.e. by terms which do not contain neither free
variables nor bound variables.

This can be achieved by using metavariables of the form $?m: \Pi
\vec{x}^{\vec{A}}.T$ where $\vec{x}$ is the collection of all free variables and
using the metavariable only in the form $?m \vec{x}$.








\section{Where Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Example}

\begin{alba}
    1 + f 10
    where
        f x := 2 * x + 25
\end{alba}

We need a metavariable for the type of $f$ and introduce $f$ as a free variable
into the context, i.e. we need the context
$$
    \Gamma, {?T_f}^{\Any_1}, f^{?T_f}
$$

In this context start to analyze \code{1 + f 10}. $+$ is an overloaded symbol
for the various numbers and other overloadings. After seeing the number $1$ as
the first argument, only addition of numbers remain. But it still remains
ambiguous.

In trying to elaborate the second argument \code{f 10} we have as the required
type one of the possible numbers. Now the elaboration becomes stuck, because the
elaboration of \code{10} is ambiguous and we don't want to nest ambiguities.

So we have to elaborate the local definition next. We have to add a metavariable
$?T_x$ for the type of $x$ and the free variable $x$ to the context.
$$
    \Gamma, {?T_f}^{\Any_1}, f^{?T_f}, {?T_x}^{\Any_1}, x^{?T_x}
$$

The we elaborate \code{2*x + 25} with any of the possible number types as the
required type. This elaboration is unique for any of the number types and
assigns the corresponding number type to the metavariable $?T_x$.

Elaborating the abstraction we get
$$
    (\lambda x^N. 2x + 25): \Pi x^N. N
$$
where $N$ is the corresponding number type. Now we get the assignment $?T_f :=
\Pi x^N. N$ and can continue with the elaboration of \code{f 10}.


\vskip 5mm
\subsubsection{General Case}

Draft: $\equiv, \approx, \cong, \simeq, \doteq, \precapprox, \precsim$.



\begin{alba}
    body
    where
        a := def   -- 'def' can be '\ x y ... := e'

    body
    where
        f x y .. := def
\end{alba}
